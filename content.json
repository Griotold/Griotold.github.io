{"pages":[{"title":"","text":"blog_2 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc < 2.8). document.addEventListener('DOMContentLoaded', function(e) { var hs = document.querySelectorAll(\"div.section[class*='level'] > :first-child\"); var i, h, a; for (i = 0; i < hs.length; i++) { h = hs[i]; if (!/^h[1-6]$/i.test(h.tagName)) continue; // it should be a header h1-h6 a = h.attributes; while (a.length > 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0","link":"/images/blog2.html"},{"title":"","text":"r_blog // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc < 2.8). document.addEventListener('DOMContentLoaded', function(e) { var hs = document.querySelectorAll(\"div.section[class*='level'] > :first-child\"); var i, h, a; for (i = 0; i < hs.length; i++) { h = hs[i]; if (!/^h[1-6]$/i.test(h.tagName)) continue; // it should be a header h1-h6 a = h.attributes; while (a.length > 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0","link":"/images/r_blog.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 안농하세요안녕하세요안녕하세욜dddd","link":"/2022/03/18/hello-world/"},{"title":"blog_2","text":"R MarkdownThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: 1summary(cars) 1234567## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including PlotsYou can also embed plots, for example: Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. 그림 1 그림 2","link":"/2022/03/17/blog2/"},{"title":"r_blog","text":"개요R MarkdownThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: 1summary(cars) 1234567## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including PlotsYou can also embed plots, for example: 1plot(pressure) Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. 그림 1이 그림은 000입니다. 1plot(1:10) 그림 2이 그림은 000입니다. 1plot(1:10) 그림 3이 그림은 000입니다. 1plot(1:10) 그림 4이 그림은 000입니다. 1plot(1:10)","link":"/2022/03/16/r_blog/"},{"title":"R을 이용한 공공데이터 분석 8장 정리","text":"1. 분석방법 통계에는 두 종류가 있다. 1) 기술통계(descriptive statistics) 평균, 최솟값, 최댓값, 중앙값 데이터의 특징을 서술한다는 의미다. 2) 추론통계(inferential statistics) 변수간의 관계를 파악한다. 평균 차이 검정, 교차분석, 상관관계분석, 회귀분석 (1) 평균 차이 검정 집단별로 평균의 차이가 실제로 있는가를 검정하는 것이다. 결과가 통계적으로 “의미가 있으려면” 우연하게 발생한 것이 아니라는 것을 통계적으로 검정해야 한다. (2) 교차분석 범주형 변수로 구성된 집단들의 관련성을 검정하는 통계 분석이다. 카이제곱검정, 카이스퀘어검정, 독립성 검정. 예를 들면, 집의 크기와 TV 크기과 관계가 있는지를 따져보는 것. 교차분석 검정의 목적은 두 변수 사이에 “관계가 있는지”를 알아보는 것이다. (3) 상관관계분석 변수 간의 상관관계(correlation)를 알아보는 것이다. 상관관계는 변수간의 연관성이다. 한 변수가 변화할때 다른 변수가 같은 방향으로 변화하는지, 반대 방향으로 변화하는지얼마만큼 변화하는지 변화의 강도와 방향을 나타나는 계수가 상관계수(r)이다. 상관계수는 -1부터 1 사이. 상관계수가 +-0.7 이상이면 높은 관계이다. (4) 회귀분석(regression analysis) 독립변수와 종속변수 간의 인과관계를 분석하는 통계적 방법을 회귀분석이라고 한다. 독립변수는 영향을 주는 변수이다. 종속변수는 영향을 받는 변수이다. 독립변수가 종속변수에 미치는 영향을 확률적으로 분석하는 것이 회귀분석이다. 독립변수가 1개이면 단순회귀분석, 2개 이상이면 다중회귀분석이다. 2. 통계 검정1) 가설(hypothesis) 가설은 어떤 현상을 설명하기 위해서 가정하는 명제이다. 가설은 귀무가설과 대립가설로 나뉜다. 귀무가설은 설정한가설이 맞을 확률이 극히 적어서 처음부터 기각될 것으로 예상되는가설이다. 귀무가설을 영가설이라고도 한다. 대립가설은 귀무가설이 기각될 경우 받아들여지는 가설이다. 대립가설은 연구자가 검정하고자 하는 가설이다. 2) 유의수준(significance level) 가설검정의 결과는 유의수준에 의해 결정된다. 유의수준은 귀무가설이 맞는데도 대립가설을 채택할 확률이다. 즉 오류를 범할 확률이다. 통계 분석에서는 p-value로 제시된다. p값이 0.01이면 오류를 범할 확률이 1%라는 의미다. 유의수준 5%는 오류를 5%까지 허용하게다는 의미다. 가설검정에서 인정하는 유의수준에는 5%, 1%, 0.1% 가 있다. 유의수준의 반대 개념은 신뢰수준(confidence level)이다. 유의수준이 5%라면, 신뢰수준은 95%이다. 3) 척도(scale) 명목척도, 서열척도, 등간척도, 비율척도 명목척도: 측정대상의 특성이나 범주를 구분하는 수치. ex) 운동선수의 번호,결혼 유무, 종교, 인종, 지역, 계절, 성별 서열척도: 측정대상의 등급순위를 나타내는 척도. ex) 계급, 사회계층, 자격등급 등간척도: 측정대상을 일정한 간격으로 구분한 척도. 서열뿐만 아니라 간격도 표시.ex) 온도, 학력, 시험점수 비율척도: 측정대상을 비율로 나타낼 수 있는 척도. ex) 연령, 무게. 3. 통계 분석 사례1) 두 집단의 평균 차이 검정 두 집단의 평균 차이를 분석할 때는 독립표본 t검정을 한다. R에서는 내장된 t.test() 함수를 쓴다. t.test()함수를 쓰는 방식은 2가지다. 방법 1. t.test(data=데이터세트, 종속변수(비교값)~독립변수(비교대상)) 방법 2. t.test(데이터세트$종속변수(비교값)~데이터세트$독립변수(비교대상)) 예제파일 mpg1.csv -&gt; 오토와 수동이 통계적으로 유의미한 차이가 있는지 판단 -귀무가설: auto와 manual의 cty 평균은 차이가 없다.-대립가설: auto와 manual의 cty 평균은 차이가 있다. 12345678910111213mpg1 &lt;- read.csv(&quot;mpg1.csv&quot;, stringsAsFactors = F)#t.test(data=mpg1, cty~trans) #t.test(mpg1$cty~mpg1$trans)도 같음# welchTwoSample t-test# data: ctybytrans# t = -4.5375, df=132.32, p-value = 1.263e-05 # 1.263/100000# alternativehypothesis: true difference in means is not equal to 0# 95 percent confidenceinterval:# -3.887311 -1.527033# sample estimates:# mean in group auto mean in group manual# 15.96815 18.67532 결론: cty 평균거리는 auto가 15.79마일, manual이 18.68마일이다. 유의수준(p)이 0.05보다 작아서 통계적으로 유의미한 차이가 있기 때문에 수동식의 평균이 자동식의 평균보다 2.7 마일 길다고 할 수 있다. 교차분석 평균의 차이가 아니라, 비율에 차이가 있는지를 검정한다. R에서는 chisq.test()함수로 한다. 귀무가설 : trans에 따라 drv의 차이가 없다. 대립가설 : trans에 따라 drv의 차이가 있다. 123#mpg1 &lt;- read.csv(&quot;solution/public_dataset/mpg1.csv&quot;, stringAsFactors = F)#table(mpg1$trans, mpg1$drv) #trans와 drv의 교차분석#prop.table(table(mpg1$trans, mpg1$drv), 1) # auto와 manual의 drv 비율분석 123456789101112131415161718# 방법1#chisq.test(mpg1$trans, mpg1$drv)# pearson's chi-squaredtest# data: mpg1$trans and mpg1$drv# X-squared = 3.1368, df = 2, p-value = 0.2084# 방법2#chisq.test(mpg1$trans, mpg1$drv)# pearson's chi-squaredtest# data: mpg1$trans and mpg1$drv# X-squared = 3.1368, df = 2, p-value = 0.2084# 방법3#summary(table(mpg1$trans, mpg1$drv))#Number of cases in table: 234 # 행의수#Number of factors: 2 #비교 범주의 수#Test for independence of all factors:# chiq = 3.1368, df = 2, p-value = 0.2084 유의수준(P-value)이 0.2084로 p&gt;0.05이다. 귀무가설 영역이므로 trans에 따라 drv에 차이가 있다고 할 수 없다. 3) 상관관계분석 상관관계분석은 R에 내장되어 있는 cor.test() 함수로 한다. 귀무가설 : cty와 hwy는 상관관계가 없다. 대립가설 : cty와 hwy는 상관관계가 있다. 123mpg1 &lt;- read.csv(&quot;mpg1.csv&quot;, stringsAsFactors = F)cor.test(mpg1$cty, mpg1$hwy) #상관관계분석 1234567891011## ## Pearson's product-moment correlation## ## data: mpg1$cty and mpg1$hwy## t = 49.585, df = 232, p-value &lt; 2.2e-16## alternative hypothesis: true correlation is not equal to 0## 95 percent confidence interval:## 0.9433129 0.9657663## sample estimates:## cor ## 0.9559159 p-value &lt;2.2e-16. 즉, 유의수준이 2.2/1016보다 작다. 따라서, 대립가설을 채택할 수 있다. 상관관계는 0.9559159이다. 매우 높은 수준이다. 결론 : cty와 hwy는 유의미하게 매우 높은 상관관계(r=0.96)에 있다.(p&lt;0.05) 4) 회귀분석(1) 단순회귀분석 단순회귀분석은 독립변수가 1개, 종속변수가 1개일 때 한다. 회귀분석의 변수는 독립변수와 종속변수가 모두 등간척도 또는 비율척도이어야 한다. 회귀분석은 R의 lm()함수로 한다. 방법은 세 가지다 12345678# 방법1# lm(data=데이터세트, 종속변수~독립변수)# 방법2# lm(종속변수 ~ 독립변수, data=데이터세트)# 방법3# lm(데이터세트$종속변수~데이터세트$독립변수) R에 있는 mtcars 데이터세트로 분석. 귀무가설 : disp는 mpg에 영향을 주지 않는다. 대립가설 : disp는 mpg에 영향을 준다. 12#help(mtcars)lm(data=mtcars, mpg~disp) # 방법1 1234567## ## Call:## lm(formula = mpg ~ disp, data = mtcars)## ## Coefficients:## (Intercept) disp ## 29.59985 -0.04122 disp의 계수(Coefficients)는 -0.04122이며, 절편은 29.59985이다. 단순회귀분석은 1차 함수를 구하는 것과 같다. mpg = 29.59985 - 0.04122 * disp 베타 = -0.04122 회귀분석에서 절편은 의미가 없다. 유의수준을 구해줘야 한다. lm()함수의 결과를 summary() 함수에 넣으면 유의수준을 비롯해서 상세한 회귀분석 결과를 알 수 있다. 123RA &lt;- lm(data=mtcars, mpg~disp) # 회귀분석 결과를 RA에 넣기summary(RA) # 상세한 분석 결과 출력 123456789101112131415161718## ## Call:## lm(formula = mpg ~ disp, data = mtcars)## ## Residuals:## Min 1Q Median 3Q Max ## -4.8922 -2.2022 -0.9631 1.6272 7.2305 ## ## Coefficients:## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 29.599855 1.229720 24.070 &lt; 2e-16 ***## disp -0.041215 0.004712 -8.747 9.38e-10 ***## ---## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1## ## Residual standard error: 3.251 on 30 degrees of freedom## Multiple R-squared: 0.7183, Adjusted R-squared: 0.709 ## F-statistic: 76.51 on 1 and 30 DF, p-value: 9.38e-10 p-value가 0.05보다 작으면 회귀모형이 적합하다고 해석한다. p-value = 9.38e-10 = 9.38/1000000000 이므로 회귀모형이 적합하다. 계수(Coefficients)에서 Estimate는 회귀계수(베타)를 의미한다. Pr(&gt;t)값은 유의수준을 의미한다. 9.38e-10이 0.05보다 작으므로 귀무가설을 기각하고, 대립가설을 채택할 수 있다. 9.38-10 옆에 ‘***’ 표시가 있다. ‘‘는 유의수준 0.001, ‘‘는 유의수준 0.01, ‘‘는 유의수준 0.05를 충족한다는 의미다. R-squared는 결정계수다. 회귀모델의 추정된 회귀식이 관측된 데이터를 설명하고 있는 비율을 계수로 나타낸 것이다. 결정계수는 상관계수(r)를 제곱한 수치이며 R^2로 표시한다. 결정계수는 0과 1 사이에 존재한다. 1에 가까울수록 추정된 회귀선을 충족하는 표본 데이터가 많아서 추정된 회귀선의 예측 정확도와 변수 관계 설명력이 높다는 것을 의미한다. 결정계수 0.7183은 높은 수준이다. Adjusted R-Squared는 수정된 결정계수다. 결정계수는 데이터와 독립변수가 많을수록 회귀식의 예측력과 무관하게 커지는 경향이 이어서 이를 보완한 결정계수이다. 연구 결과에서 수정된 결정계수를 밝히는 것이 일반적이다. 여기서 수정된 결정계수는 0.709 분석결과 : 회귀모형은 유의수준 p &lt;0.001에서 적합하며, 회귀식의 수정된 결정계수는 0.709이다. 배기량(disp)이 연비(mpg)에 미치는 회귀계수(베타)는 유의수준 p&lt;0.001에서 -0.04이다. (2) 다중회귀분석 다중회귀분석은 종속변수에 영향을 주는 독립변수가 복수일 때 분석하는 방식이다. 다중회귀분석에서는 독립변수들을 ‘+’ 기호로 연결한다. 12345678# 방법1# lm(data=데이터세트, 종속변수~독립변수1+독립변수2+...)# 방법2# lm(종속변수 ~ 독립변수1+독립변수2+..., data=데이터세트)# 방법3#lm(데이터세트$종속변수 ~ 데이터세트$독립변수1+데이터세트$독립변수2+...) mtcars 데이터로 실습. mpg에는 disp(배기량) 이외에도 hp(마력)와 wt(중량)가 영향을 미칠 수 있다. 1lm(data=mtcars, mpg~disp+hp+wt) # 방법1 1234567## ## Call:## lm(formula = mpg ~ disp + hp + wt, data = mtcars)## ## Coefficients:## (Intercept) disp hp wt ## 37.105505 -0.000937 -0.031157 -3.800891 mpg = 37.105505 - 0.000937 * disp - 0.031157 * hp - 3.800891 * wt summary() 함수로 상세결과 확인한다. 123RA &lt;- lm(data=mtcars, mpg~disp+hp+wt) # 회귀분석 결과를 RA에 넣기summary(RA) 1234567891011121314151617181920## ## Call:## lm(formula = mpg ~ disp + hp + wt, data = mtcars)## ## Residuals:## Min 1Q Median 3Q Max ## -3.891 -1.640 -0.172 1.061 5.861 ## ## Coefficients:## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 37.105505 2.110815 17.579 &lt; 2e-16 ***## disp -0.000937 0.010350 -0.091 0.92851 ## hp -0.031157 0.011436 -2.724 0.01097 * ## wt -3.800891 1.066191 -3.565 0.00133 ** ## ---## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1## ## Residual standard error: 2.639 on 28 degrees of freedom## Multiple R-squared: 0.8268, Adjusted R-squared: 0.8083 ## F-statistic: 44.57 on 3 and 28 DF, p-value: 8.65e-11 p값은 8.65e-11로 유의수준 0.001보다 작아 회귀모형은 적합하다. disp의 계수는 -0.000937 hp의 계수는 -0.031157 wt의 계수는 -3.800891 Pr(&gt;t)를 보면 disp의 유의수준은 0.92851로 허용되지 않는다. 마찬가지로 hp의 유의수준은 0.01097로 허용된다. wt의 유의수준은 0.00133으로 허용된다. 단순회귀분석에서는 disp가 영향을 주었는데, 다중회귀분석에서는 영향을 주지 않는다. 수정된 결정계수는 0.8083으로 높아서 회귀모델의 설명력이 높다. 결론 : 회귀모형은 유의수준 p &lt; 0.001에서 적합하며, 회귀식의 수정된 결정계수는 0.81이다. 3개 독립변수가 연비에 미치는 회귀계수(베타)는 hp가 -0.03(p&lt;0.05), wt가 -3.80(p&lt;0.01)이었고, disp는 없었다.","link":"/2022/03/15/ch08-2-/"},{"title":"아나콘다 설치","text":"아나콘다 설치웹사이트 주소 : https://www.anaconda.com/products/individual (작성방식 예시) 깃허브에서 R_edu 프로젝트를 다운로드 받는다. 1$ git clone 주소 여기서 다운로드 받는거다/images/source/images/ananconda_install 설치후 아나콘다 네이게이토 쥬피터 랩 런치 → AI폴더 → 01.ipynb 파일 생성","link":"/2022/03/15/ananconda_install/"},{"title":"파이참 설치","text":"파이참 설치 구글에 파이참 검색 셋업 실행 시스템 환경 변수 편집 /images/pychamsource/images/pycham 1~5줄이 있는지 확인해야 한다. 저게 있으려면 셋업 실행할 때 박스칸을 체크해줘야 한다. 만약 깜빡하고 안했으면 수기로 작성해줘야 한다. 환경 변수 편집 대화상자는 시스템 속성 대화상자에서 환경 변수를 클릭하면 된다.","link":"/2022/03/15/pycham/"},{"title":"colab 소개","text":"Colab이란? Colaboratory&amp;#40;줄여서 ‘Colab’이라고 함&amp;#41;을 통해 브라우저 내에서 Python 스크립트를 작성하고 실행할 수 있습니다. 구성이 필요하지 않음 GPU 무료 액세스 간편한 공유 학생이든, 데이터 과학자든, AI 연구원이든 Colab으로 업무를 더욱 간편하게 처리할 수 있습니다. Colab 소개 영상에서 자세한 내용을 확인하거나 아래에서 시작해 보세요. 시작하기지금 읽고 계신 문서는 정적 웹페이지가 아니라 코드를 작성하고 실행할 수 있는 대화형 환경인 Colab 메모장입니다. 예를 들어 다음은 값을 계산하여 변수로 저장하고 결과를 출력하는 간단한 Python 스크립트가 포함된 코드 셀입니다. 12seconds_in_a_day = 24 * 60 * 60seconds_in_a_day 86400 위 셀의 코드를 실행하려면 셀을 클릭하여 선택한 후 코드 왼쪽의 실행 버튼을 누르거나 단축키 ‘Command/Ctrl+Enter’를 사용하세요. 셀을 클릭하면 코드 수정을 바로 시작할 수 있습니다. 특정 셀에서 정의한 변수를 나중에 다른 셀에서 사용할 수 있습니다. 12seconds_in_a_week = 7 * seconds_in_a_dayseconds_in_a_week 604800 Colab 메모장을 사용하면 실행 코드와 서식 있는 텍스트를 이미지, HTML, LaTeX 등과 함께 하나의 문서로 통합할 수 있습니다. Colab 메모장을 만들면 Google Drive 계정에 저장됩니다. Colab 메모장을 간편하게 공유하여 동료나 친구들이 댓글을 달거나 수정하도록 할 수 있습니다. 자세히 알아보려면 Colab 개요를 참조하세요. 새 Colab 메모장을 만들려면 위의 파일 메뉴를 사용하거나 다음 링크로 이동하세요. 새 Colab 메모장 만들기 Colab 메모장은 Colab에서 호스팅하는 Jupyter 메모장입니다. Jupyter 프로젝트에 관해 자세히 알아보려면 jupyter.org를 참조하세요. 데이터 과학Colab을 통해 인기 있는 Python 라이브러리를 최대한 활용하여 데이터를 분석하고 시각화할 수 있습니다. 아래 코드 셀에서는 Numpy를 사용하여 임의의 데이터를 생성하고 매트플롯립으로 이를 시각화합니다. 셀을 클릭하면 코드 수정을 바로 시작할 수 있습니다. 1234567891011import numpy as npfrom matplotlib import pyplot as pltys = 200 + np.random.randn(100)x = [x for x in range(len(ys))]plt.plot(x, ys, '-')plt.fill_between(x, ys, 195, where=(ys &gt; 195), facecolor='g', alpha=0.6)plt.title(&quot;Sample Visualization&quot;)plt.show() Google Drive 계정에서 스프레드시트를 비롯한 데이터를 Colab 메모장으로 가져오거나 GitHub 등의 여러 다른 소스에서 데이터를 가져올 수 있습니다. Colab을 데이터 과학에 활용하는 방법과 데이터 가져오기에 관해 자세히 알아보려면 데이터 사용하기 아래 링크를 참조하세요. 머신러닝Colab을 사용하면 코드 몇 줄만으로 이미지 데이터세트를 가져오고, 이 데이터세트로 이미지 분류기를 학습시키며, 모델을 평가할 수 있습니다. Colab 메모장은 Google 클라우드 서버에서 코드를 실행하므로 사용 중인 컴퓨터의 성능과 관계없이 GPU 및 TPU를 포함한 Google 하드웨어의 성능을 활용할 수 있습니다. 브라우저만 있으면 사용 가능합니다. Colab은 다음과 같은 분야의 머신러닝 커뮤니티에서 널리 쓰이고 있습니다. TensorFlow 시작하기 신경망 개발 및 학습시키기 TPU로 실험하기 AI 연구 보급하기 튜토리얼 만들기 머신러닝 적용 사례를 보여 주는 Colab 메모장 샘플을 확인하려면 아래 머신러닝 예시를 참조하세요. 추가 리소스Colab에서 메모장 사용하기 Colaboratory 개요 Markdown 가이드 라이브러리 가져오기 및 종속 항목 설치하기 GitHub에서 노트 저장 및 로드하기 대화형 양식 대화형 위젯 Colab의 TensorFlow 2 데이터로 작업하기 데이터 로드: 드라이브, 스프레드시트, Google Cloud Storage 차트: 데이터 시각화하기 BigQuery 시작하기 머신러닝 단기집중과정다음은 Google 온라인 머신러닝 과정에서 가져온 일부 메모장입니다. 전체 과정 웹사이트에서 자세한 내용을 확인하세요. Pandas DataFrame 소개 합성 데이터를 사용하는 tf.keras 선형 회귀 가속 하드웨어 사용하기 GPU를 사용한 TensorFlow TPU를 사용한 TensorFlow 추천 예시 NeMo Voice Swap: Nvidia의 NeMo 대화형 AI 툴킷을 사용하여 오디오 파일의 음성을 컴퓨터에서 생성된 음성으로 변환하세요. 이미지 분류기 재훈련: 사전에 훈련된 이미지 분류기를 기반으로 꽃을 분류하기 위한 Keras 모델을 구축합니다. 텍스트 분류: IMDB 영화 리뷰를 긍정적인 리뷰 또는 부정적인 리뷰로 분류합니다. 스타일 트랜스퍼: 딥 러닝을 사용하여 이미지 간에 스타일을 전이시킵니다. Multilingual Universal Sentence Encoder Q&amp;A: 머신러닝 모델을 사용하여 SQuAD 데이터 세트의 질문에 답변합니다. 동영상 보간 유형: 동영상에서 첫 프레임과 마지막 프레임 사이에 발생한 내용을 예측합니다.","link":"/2022/03/14/colab_intro/"},{"title":"파이썬 기초 문법","text":"Hello World1print(&quot;Hello, World!&quot;) Hello, World! 주석 처리 코드 작업 시, 특정 코드에 대해 설명 사용자 정의 함수 작성 시, 클래스 작성 시..(도움말 작성..) 123456# 한 줄 주석 처리&quot;&quot;&quot;여러 줄 주석 처리 시 (큰따옴표도 가능, 통일만 되면)&quot;&quot;&quot;print(&quot;Hello&quot;) Hello 변수 ( Scalar) 객체(object)로 구현이 됨 하나의 자료형(Type)을 가진다. (이것만 기억!) 클래스로 정의가 됨. 다양한 함수들이 존재 함. int int 정수를 표현하는 데 사용함. 12345678# 데이터 전처리...# 데이터 전처리를 잘해야! 분석도 잘함. 예측 모형도 잘 만듬.# 데이터 전처리를 잘하기 위해서는 기초문법이 중요함.num_int = 1print(num_int)print(type(num_int)) 1 &lt;class 'int'&gt; float 실수를 표현하는데 사용한다. 123num_float = 0.2print(num_float)print(type(num_float)) 0.2 &lt;class 'float'&gt; bool True와 False로 나타내는 Boolean 값을 표현하는 데 사용한다. 1234bool_true = Trueprint(bool_true)print(type(bool_true)) True &lt;class 'bool'&gt; None Null을 나타내는 자료형으로 None이라는 한 가지 값만 가집니다. 123none_x = Noneprint(none_x)print(type(none_x)) None &lt;class 'NoneType'&gt; 사칙연산 정수형 사칙 연산 123456789a = 13b = 47print('a + b = ', a + b)print(a - b )print(a * b)print(a / b) # 실수형을 반환한다!!!print(a // b) # 나머지는 버린다.print(a % b) # 나머지만 가져온다.print(a ** b) # a를 b제곱한다. a + b = 60 -34 611 0.2765957446808511 0 13 22664052024539238871968220999332552715703774239747717 실수형 사칙연산123456789a = 13.0b = 47.0print('a + b = ', a + b)print(a - b )print(a * b)print(a / b) # 실수형을 반환한다!!!print(a // b) # 나머지는 버린다.print(a % b) # 나머지만 가져온다.print(a ** b) # a를 b제곱한다. a + b = 60.0 -34.0 611.0 0.2765957446808511 0.0 13.0 2.2664052024539239e+52 논리형 연산자 Bool 형은 True와 False 값으로 정의 AND / OR 123456789101112131415x = 5 &gt; 4# print(x)y = 3 &gt; 4# print(y)print(x and x)print(x and y)print(y and x)print(y and y)print(&quot;----&quot;)print(x or x)print(x or y)print(y or x)print(y or y) True False False False ---- True True True False 비교 연산자 부등호를 의미합니다. 비교 연산자를 True와 False값을 도출 논리 &amp; 비교 연산자 응용12var = input(&quot;입력하여 주세요..&quot;)print(type(var)) 입력하여 주세요123 &lt;class 'str'&gt; input은 문자열로 만들어버린다. 형변환을 해준다. 문자열, 정수, 실수 등등등 12var = int(&quot;1&quot;)print(type(var)) &lt;class 'int'&gt; 12var = int(input(&quot;숫자를 입력하여 주세요&quot;))print(type(var)) 숫자를 입력하여 주세요12345 &lt;class 'int'&gt; 123456789num1 = int(input(&quot;숫자를 입력하여 주세요...&quot;)) # 10num2 = int(input(&quot;숫자를 입력하여 주세요...&quot;)) # 3num3 = int(input(&quot;숫자를 입력하여 주세요...&quot;)) # 5num4 = int(input(&quot;숫자를 입력하여 주세요...&quot;)) # 7var1 = num1 &gt;= num2 # Truevar2 = num3 &lt; num4 # Trueprint(var1 and var2)print(var1 or var2) 숫자를 입력하여 주세요...10 숫자를 입력하여 주세요...3 숫자를 입력하여 주세요...5 숫자를 입력하여 주세요...7 True True 변수 (Non Scalar) 문자열을 입력 12print(&quot;'Hello, World!'&quot;)print('&quot;Hello, World!&quot;') 'Hello, World!' &quot;Hello, World!&quot; 1print(&quot;Hello world&quot;) Hello world 섞이면 안 된다. string 연산자 덧셈 연산자를 써보자. 1234str1 = &quot;Hello &quot;str2 = &quot;World! &quot;print(str1 + str2) Hello World! 곱셈 연산자를 사용해본다. 12greeting = str1 + str2print(greeting * 4) Hello World! Hello World! Hello World! Hello World! Indexing 문자열 인덱싱은 각각의 문자열 안에서 범위를 지정하여 특정 문자를 추출한다. 123greeting = &quot;Hello Kaggle!&quot;print(greeting[6])print(greeting[10]) K l 0부터 시작해서 6번째가 “K”이다. 공백도 포함해서 슬라이싱 범위를 지정하고 데이터를 가져온다. 1234567greetingprint(greeting[:])print(greeting[6:])print(greeting[:6])print(greeting[3:8]) # 끝은 n-1이 범위로 지정된다.print(greeting[0:9:2]) # 여기서 2는 두 칸씩 뛰라는 소리 Hello Kaggle! Kaggle! Hello lo Ka HloKg 1# greeting[13] # 스트링 인덱스가 범위 밖에 있다는 에러 메세지 문자열을 바꾸려면 바꾸고 싶은 부분을 기준으로 나누고 원하는 문자를 삽입한다. 1234a = &quot;pithon&quot;a[:1]a[2:]a[:1] + 'y' + a[2:] 'python' 문자열 포매팅 문자열 안의 특정한 값을 바꿔야 할 경우가 있을 때 사용하는 기법. 12&quot;I eat %d apples.&quot; % 3 'I eat five apples.' 1&quot;I eat %s apples.&quot; % &quot;five&quot; 'I eat five apples.' 숫자를 넣기 위해서는 %d 문자열을 넣기 위해서는 %s 12number = 3&quot;I eat %d apples.&quot; % number 'I eat 3 apples.' 숫자를 바로 대입하나 위 처럼 숫자 값을 나타내는 변수를 대입하나 결과는 같다. 123number = 10day = &quot;three&quot;&quot;I ate %d apples. so I was sick for %s days.&quot; %(number, day) 'I ate 10 apples. so I was sick for three days.' 위 처럼 2개 이상의 값을 넣으려면 마지막 % 다음 괄호 안에 콤마로 구분하여 각각의 값을 넣어 주면 된다. 문자열 포맷 코드 정수와 문자열 외에도 다양한 것을 대이할 수 있다. %s 는 문자열 %c 는 문자 1개(character) %d 는 정수(integer) %f 는 부동소수(floating-point) %o 는 8진수 %x 는 16진수 %% 는 Literal % (문자 % 자체) 12&quot;I have %s apples.&quot; % 3 'I have 3 apples.' 1&quot;rate is %s&quot; % 2.345 'rate is 2.345' 흥미롭게도 %s 포맷 코드는 어떤 형태의 값이든 변환해 넣을 수 있다. 왜냐하면 % 뒤에 있는 값을 문자열로 바꾸기 때문이다. 포매팅 연산자 %d와 %를 같이 쓸때는 %%를 쓴다.12&quot;Error is %d%%.&quot; % 98# %d%로 쓰면 'incomplete format'이란 에러가 뜬다. 'Error is 98%.' 포맷 코드와 숫자 함께 사용하기 포맷 코드를 숫자와 함께 사용하면 더욱 유용하다 정렬과 공백 1&quot;%10s&quot; % &quot;hi&quot; ' hi' %10s는 전체 길이가 10개인 문자열 공간에서 대입되는 값을 오른쪽으로 정렬하고 그 앞의 나머지는 공백으로 남겨 두라는 의미다. 1&quot;%-10sjane&quot; % 'hi' 'hi jane' hi를 왼쪽으로 정렬하고 나머지는 공백으로 채웠음을 볼 수 있다. 소수점 표현하기 1&quot;%0.4f&quot; % 3.42134234 '3.4213' 3.42134234를 소수점 네 번째 자리까지만 나타내고 싶은 경우에는 위와 같이 사용한다. ‘.’ 뒤의 숫자 4는 소수점 뒤에 나올 숫자의 개수를 의미한다. 1&quot;%10.4f&quot; %3.42134234 ' 3.4213' 위 예는 숫자 3.42134234를 소수점 네 번째 자리까지만 표시하고 전체 길이가 10개인 문자열 공간에서 오른쪽으로 정렬하는 예를 보여준다. format 함수를 사용한 포맷팅 문자열의 format 함수를 사용하면 좀 더 발전된 스타일로 문자열 포맷을 지정할 수 있다. 1&quot;I eat {0} apples&quot;.format(3) 'I eat 3 apples' {0} 부분이 숫자 3으로 바뀌었다. 12number = 3&quot;I eat {0} apples&quot;.format(number) 'I eat 3 apples' {0} 항목이 number 변수 값인 3으로 바뀌었다. 123number = 10day = &quot;three&quot;&quot;I ate {0} apples. so I was sick for {1} days.&quot;.format(number, day) 'I ate 10 apples. so I was sick for three days.' 2개 이상의 값을 넣을 경우 문자열의 {0}, {1}과 같은 인덱스 항목이 format 함수의 입력값으로 순서에 맞게 바뀐다. 1&quot;I ate {number} apples. so I was sick for {day} days.&quot;.format(number=10, day=3) 'I ate 10 apples. so I was sick for 3 days.' name=value와 같은 형태의 입력값이 있어야만 한다. 1&quot;I ate {0} apples. so I was sick for {day} days.&quot;.format(10, day=3) 'I ate 10 apples. so I was sick for 3 days.' 위와 같이 인덱스 항목과 name=value 형태를 혼용하는 것도 가능하다. 1&quot;{0:&lt;10}&quot;.format(&quot;hi&quot;) 'hi ' :&lt;10 표현식을 사용하면 치환되는 문자열을 왼쪽으로 정렬하고 문자열의 총 자릿수를 10으로 맞출 수 있다. 1&quot;{0:&gt;10}&quot;.format(&quot;hi&quot;) ' hi' 위 예문은 오른쪽 정렬 1&quot;{0:^10}&quot;.format(&quot;hi&quot;) ' hi ' 가운데 정렬은 :^ 기호를 사용한다. 1&quot;{0:=^10}&quot;.format(&quot;hi&quot;) '====hi====' 정렬할 때 공백 대신 지정한 문자 값으로 채워 넣는 것도 가능하다. 채워 넣을 문자 값은 정렬 문자 &lt;, &gt;, ^ 바로 앞에 넣어야 한다. 1&quot;{0:!&lt;10}&quot;.format(&quot;hi&quot;) 'hi!!!!!!!!' 12y = 3.42134234&quot;{0:0.4f}&quot;.format(y) '3.4213' 위 예는 format 함수를 사용해 소수점을 4자리까지만 표현하는 방법을 보여 준다. 1&quot;{0:10.4f}&quot;.format(y) ' 3.4213' 위 예는 자릿수를 10으로 맞춰준 것이다. f 문자열 포매팅 다음과 같이 문자열 앞에 f 접두사를 붙이면 f 문자열 포매팅 기능을 사용할 수 있다. f 문자열 포매팅은 표현식(변수와 +, -같은 수식을 함께 사용하는 것)을 지원한다. 123name = '홍길동'age = 30f'나의 이름은 {name}입니다. 나이는 {age}입니다.' '나의 이름은 홍길동입니다. 나이는 30입니다.' 12age = 30f'나는 내년이면 {age+1}살이 된다.' '나는 내년이면 31살이 된다.' 딕셔너리는 f 문자열 포매팅에서 다음과 같이 사용할 수 있다. 12d = {'name':'홍길동', 'age':30}f'나의 이름은 {d[&quot;name&quot;]}입니다. 나이는 {d[&quot;age&quot;]}입니다.' '나의 이름은 홍길동입니다. 나이는 30입니다.' 정렬은 다음과 같이 할 수 있다. 1234f'{&quot;hi&quot;:&lt;10}' #왼쪽 정렬f'{&quot;hi&quot;:&gt;10}' #오른쪽 정렬f'{&quot;hi&quot;:^10}' #가운데 정렬 ' hi ' 공백 채우기 1f'{&quot;hi&quot;:=^10}' '====hi====' 소수점 표현 12y = 3.42134234f'{y:0.4f}' '3.4213' 문자열 관련 함수들 문자열 내장 함수 count함수 문자 개수 세기 12a = &quot;hobby&quot;a.count('b') #b의 개수를 돌려준다. 2 find함수 위치 알려주기1 123a = &quot;python is the best choice&quot;a.find('b') # 14a.find('k') # -1 -1 문자열 중 문자 b가 처음으로 나온 위치가 14라는 뜻 만약 k처럼 문자가 없으면 -1을 반환한다. index함수 위치 알려주기2 12a = &quot;Life is too short&quot;a.index('t') 8 find함수와 마찬가지로 문자 t가 맨 처음으로 나온 위치를 반환한다. 만약 찾는 문자열이 존재하지 않는다면 오류를 발생시킨다. join 함수 문자열 삽입 1&quot;,&quot;.join('abcd') 'a,b,c,d' abcd 문자열의 각각 ‘,’를 삽입한다. upper 함수 / lower 함수 소문자를 대문자로 바꾸기 대문자를 소문자로 바꾸기 12a = &quot;hi&quot;a.upper() 'HI' lstrip 함수 / rstrip 함수 / strip 함수 왼쪽 공백 지우기 오른쪽 공백 지우기 양쪽 공백 지우기 12a = &quot; hi &quot;a.lstrip() 'hi ' replace 함수 문자열 바꾸기 12a = &quot;Life is too short&quot;a.replace(&quot;Life&quot;, &quot;Your leg&quot;) #a.replace(바꾸고 싶은 문자열, 바꿀 문자열) 'Your leg is too short' split 함수 문자열 나누기 1234a = &quot;Life is too short&quot;a.split()b = &quot;a:b:c:d&quot;b.split(':') ['a', 'b', 'c', 'd'] a.split() 처럼 괄호안에 아무 값도 넣어 주지 않으면 공백을 기준으로 문자열을 나눈다. 만약 b.split(‘:’) 처럼 괄호 안에 특정 값이 있을 경우에는 그걸 구분자로 한다. 리스트 시퀀스 데이터 타입 데이터에 순서가 존재하냐! 슬라이싱이 가능해야 함. 대괄호(‘[값1, 값2, 값3]’) 12345678910111213a = [] # 빈 리스트 생성a_func = list() # 빈 리스트 생성b = [1] # 숫자가 요소가 될 수 있다.c = ['apple'] # 문자열도 요소가 될 수 있다.d = [1, 2, ['apple']] # 리스트 안에 또 다른 리스트를 요소로 넣을 수 있다.print(a)print(a_func)print(b)print(c)print(d)print(type(d)) [] [] [1] ['apple'] [1, 2, ['apple']] &lt;class 'list'&gt; 리스트 슬라이싱123456789a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# print(a)print(a[0]) print(a[6:])print(a[:5])print(a[3:5])print(a[4:7])print(a[2:8])print(a[1:9:3]) 1 [7, 8, 9, 10] [1, 2, 3, 4, 5] [4, 5] [5, 6, 7] [3, 4, 5, 6, 7, 8] [2, 5, 8] 12345678a = [[&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;], 1] # 중첩 리스트print(a[0])print(a[0][1])print(a[0][0][4]) # 애플의 eprint(a[0][0][-1]) # 애플의 eprint(a[0][2][2]) # 체리의 eprint(a[0][2][-4]) # 체리의 e ['apple', 'banana', 'cherry'] banana e e e e 1234a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]print(a[::-1]) # 역순print(a[::2]) [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] [1, 3, 5, 7, 9] 리스트 연산자1234567a = [&quot;john&quot;, &quot;evan&quot;]b = [&quot;alice&quot;, &quot;sarah&quot;]c = a + bprint(c)d = b + aprint(d) ['john', 'evan', 'alice', 'sarah'] ['alice', 'sarah', 'john', 'evan'] 1234c = a * 3d = b * 0print(&quot;a * 3 = &quot;, c)print(&quot;b * 0 = &quot;, d) a * 3 = ['john', 'evan', 'john', 'evan', 'john', 'evan'] b * 0 = [] 리스트 길이 구하기 리스트 길이를 구하기 위해서는 len 함수를 사용한다 12a = [1, 2, 3]len(a) 3 리스트 수정 및 삭제123a = [0, 1, 2]a[1] = &quot;b&quot;print(a) [0, 'b', 2] 리스트 값 추가하기123a = [100, 200, 300]a.append(400)print(a) [100, 200, 300, 400] a를 저장해주지 않았는데도 append메서드를 사용했더니 자동저장되었다. 파이썬에 이런게 은근 많다. 모두 알려고 하지 말고 만나는대로 습득하는 수밖에 없다. 12a.append([500, 600])print(a) # 원하는 답이 안 나옴 [100, 200, 300, 400, [500, 600]] 1234a = [100, 200, 300]a.extend([500, 600])print(a) [100, 200, 300, 500, 600] 1234a = [ 0, 1, 2]# a.insert(인덱스번호, 넣고자하는 값)a.insert(1, 100)print(a) [0, 100, 1, 2] 리스트 값 삭제하기12345a = [4, 3, 2, 1, &quot;A&quot;]a.remove(1) # 리스트에서 첫번째로 나오는 값을 삭제(인덱스 번호가 아니다)print(a)a.remove(&quot;A&quot;)print(a) [4, 3, 2, 'A'] [4, 3, 2] 1234567a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]del a[1] # 인덱스 번호print(a)del a[1:5]print(a) # 3, 4, 5, 6이 지워짐 [1, 3, 4, 5, 6, 7, 8, 9, 10] [1, 7, 8, 9, 10] pop 함수 리스트의 맨 마지막 요소를 돌려주고 그 요소는 삭제한다. 1234b = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]x = b.pop()print(x)print(b) d ['a', 'b', 'c'] 그 외 메서드12345a = [0, 1, 2, 3]print(a)a.clear()print(a) [0, 1, 2, 3] [] 123a = [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;]print(a.index(&quot;a&quot;))print(a.index(&quot;b&quot;)) 0 2 123456789a = [1, 4, 5, 2, 3]b = [1, 4, 5, 2, 3]a.sort()print(&quot;sort(): &quot;, a)# 내림차순, sort()b.sort(reverse=True)print(&quot;sort(reverse=True): &quot;, b) sort(): [1, 2, 3, 4, 5] sort(reverse=True): [5, 4, 3, 2, 1] 내림차순 같은 옵션을 알아내는 방법은 구글링이다. 12c = [4, 3, 2, 'a']# c.sort() reverse 함수 리스트 뒤집기 리스트를 역순으로 123a = ['a', 'b', 'c']a.reverse()print(a) ['c', 'b', 'a'] index 함수 위치 반환 12a = [1, 2, 3]a.index(3) # 3의 인덱스값은 2이다. 2 extend 리스트 확장 extend(x)에서 x에는 리스트만 올 수 있다. a.extend([4, 5])는 a += [4, 5]와 동일하다. 123456a = [1, 2, 3]a.extend([4, 5])print(a)b = [6, 7]a.extend(b)print(a) [1, 2, 3, 4, 5] [1, 2, 3, 4, 5, 6, 7] 튜플 List와 비슷하다. 슬라이싱, 인덱싱 등등 (vs 리스트) : 튜플은 수정 삭제가 안된다. 123456tuple1 = (0) # 끝에 콤마(,)를 붙이지 않을 때 --&gt; inttuple2 = (0,) # 끝에 콤마 붙일 때 --&gt; tupletuple3 = 0, 1, 2 # 괄호를 생략해도 무방하다.print(type(tuple1)) print(type(tuple2)) print(type(tuple3)) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 12345a = (0, 1, 2, 3, 'a')print(type(a))# del a[4] -&gt; 튜플은 수정이 안된다.# a[1] = &quot;b&quot; -&gt; 튜플은 수정이 안된다. &lt;class 'tuple'&gt; 튜플 인덱싱 및 슬라이싱 하기1234a = (0, 1, 2, 3, 'a')print(a[1])print(a[3])print(a[4]) 1 3 a 더하기 곱셈 연산자 사용123456t1 = (0, 1, 2, 3)t2 = (4, 5, 6 ,7)print(t1 + t2)print(t1 * 3)print(t2 * 0) (0, 1, 2, 3, 4, 5, 6, 7) (0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3) () 딕셔너리 key-value값으로 나뉨. 123456789dict_01 = {'teacher' : 'evan', 'class' : 601, 'student' : 24, '학생이름' : ['A', 'Z']}print(dict_01)print(dict_01['teacher'])print(dict_01['class'])print(dict_01['학생이름'])# print(dict_01['선생님']) {'teacher': 'evan', 'class': 601, 'student': 24, '학생이름': ['A', 'Z']} evan 601 ['A', 'Z'] 1print(dict_01.keys()) dict_keys(['teacher', 'class', 'student', '학생이름']) 1print(dict_01.values()) dict_values(['evan', 601, 24, ['A', 'Z']]) 1dict_01.items() # 튜플 형태로 묶이더라 dict_items([('teacher', 'evan'), ('class', 601), ('student', 24), ('학생이름', ['A', 'Z'])]) 123456print(dict_01.get(&quot;teacher&quot;)) # get메서드print(dict_01.get(&quot;선생님&quot;))print(dict_01.get(&quot;class&quot;))# print(dict_01['선생님']) # get을 써주는 이유. 키 값이 없을 때 None을 떨궈주면서 다음 줄을 실행시켜준다.print(dict_01.get(&quot;students&quot;))print(dict_01.get(&quot;선생님&quot;, &quot;없어용&quot;)) # None말고 지정한 값 떨궈주는 방법 evan None 601 None 없어용 조건문 &amp; 반복문조건문 일상에서 조건문 언제쓸까요? 12345weather = &quot;비&quot;if weather == &quot;비&quot;: # 조건식 True가 나오면 print(&quot;우산을 가져간다.&quot;)else: print(&quot;우산을 가져가지 않는다.&quot;) 우산을 가져간다. 등급표를 만들어보자 60점 이상 합격 / 그외는 불합격 숫자는 아무거나 써도 상관없음 12345score = 61if score &gt;= 60 : print(&quot;합격&quot;)else: print(&quot;불합격&quot;) 합격 123456score = int(input(&quot;점수를 입력하세요...&quot;)) # input은 문자열로 인식을 하니까 정수형으로 형변환if score &gt;= 60 : print(&quot;합격&quot;)else: print(&quot;불합격&quot;) 점수를 입력하세요...70 합격 등급으로 나눠보자 90점 이상은 A등급 80점 이상은 B등급 나머지는 F등급 if-elif-else 12345678score = int(input(&quot;점수를 입력해 주세요: &quot;))if score &gt;= 90: print(&quot;A등급&quot;)elif score &gt;= 80: print(&quot;B등급&quot;)else: print(&quot;F등급&quot;) 점수를 입력해 주세요: 95 A등급 반복문 안녕하세요! 10번 반복하세요. 12345678910print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;) 2번째 과제 : 안녕하세요! 789256번 반복하세요. 123# 789... 뭐시기 반복하기for i in range(3): print(i + 1, &quot;안녕하세요!&quot;) 1 안녕하세요! 2 안녕하세요! 3 안녕하세요! 12345count = range(3)print(count)for n in count: print(n) range(0, 3) 0 1 2 123456789count = range(50)print(count)for n in count: print(str(n + 1) + &quot;번째&quot;) if (n + 1) == 5: print(&quot;그만&quot;) break print(&quot;슈팅&quot;) range(0, 50) 1번째 슈팅 2번째 슈팅 3번째 슈팅 4번째 슈팅 5번째 그만 123456a = &quot;hello&quot;for x in a: if x == &quot;l&quot;: break print(x) h e 반복문 작성 방식은 다양하다. zip, range, enumerate, len 등등 123alphabets = ['A', 'B', 'c']for index, value in enumerate(alphabets): print(index, value) 0 A 1 B 2 c","link":"/2022/03/21/basic_grammer/"}],"tags":[],"categories":[]}