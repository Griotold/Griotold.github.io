{"pages":[{"title":"","text":"blog_2 // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc < 2.8). document.addEventListener('DOMContentLoaded', function(e) { var hs = document.querySelectorAll(\"div.section[class*='level'] > :first-child\"); var i, h, a; for (i = 0; i < hs.length; i++) { h = hs[i]; if (!/^h[1-6]$/i.test(h.tagName)) continue; // it should be a header h1-h6 a = h.attributes; while (a.length > 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0","link":"/images/blog2.html"},{"title":"","text":"r_blog // Pandoc 2.9 adds attributes on both header and div. We remove the former (to // be compatible with the behavior of Pandoc < 2.8). document.addEventListener('DOMContentLoaded', function(e) { var hs = document.querySelectorAll(\"div.section[class*='level'] > :first-child\"); var i, h, a; for (i = 0; i < hs.length; i++) { h = hs[i]; if (!/^h[1-6]$/i.test(h.tagName)) continue; // it should be a header h1-h6 a = h.attributes; while (a.length > 0) h.removeAttribute(a[0].name); } }); /*! jQuery v3.6.0 | (c) OpenJS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(C,e){\"use strict\";var t=[],r=Object.getPrototypeOf,s=t.slice,g=t.flat?function(e){return t.flat.call(e)}:function(e){return t.concat.apply([],e)},u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return\"function\"==typeof e&&\"number\"!=typeof e.nodeType&&\"function\"!=typeof e.item},x=function(e){return null!=e&&e===e.window},E=C.document,c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement(\"script\");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?n[o.call(e)]||\"object\":typeof e}var f=\"3.6.0\",S=function(e,t){return new S.fn.init(e,t)};function p(e){var t=!!e&&\"length\"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&(\"array\"===n||0===t||\"number\"==typeof t&&0","link":"/images/r_blog.html"},{"title":"about","text":"","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 안농하세요안녕하세요안녕하세욜dddd","link":"/2022/03/18/hello-world/"},{"title":"blog_2","text":"R MarkdownThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: 1summary(cars) 1234567## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including PlotsYou can also embed plots, for example: Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. 그림 1 그림 2","link":"/2022/03/17/blog2/"},{"title":"r_blog","text":"개요R MarkdownThis is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see http://rmarkdown.rstudio.com. When you click the Knit button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: 1summary(cars) 1234567## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 Including PlotsYou can also embed plots, for example: 1plot(pressure) Note that the echo = FALSE parameter was added to the code chunk to prevent printing of the R code that generated the plot. 그림 1이 그림은 000입니다. 1plot(1:10) 그림 2이 그림은 000입니다. 1plot(1:10) 그림 3이 그림은 000입니다. 1plot(1:10) 그림 4이 그림은 000입니다. 1plot(1:10)","link":"/2022/03/16/r_blog/"},{"title":"R을 이용한 공공데이터 분석 8장 정리","text":"1. 분석방법 통계에는 두 종류가 있다. 1) 기술통계(descriptive statistics) 평균, 최솟값, 최댓값, 중앙값 데이터의 특징을 서술한다는 의미다. 2) 추론통계(inferential statistics) 변수간의 관계를 파악한다. 평균 차이 검정, 교차분석, 상관관계분석, 회귀분석 (1) 평균 차이 검정 집단별로 평균의 차이가 실제로 있는가를 검정하는 것이다. 결과가 통계적으로 “의미가 있으려면” 우연하게 발생한 것이 아니라는 것을 통계적으로 검정해야 한다. (2) 교차분석 범주형 변수로 구성된 집단들의 관련성을 검정하는 통계 분석이다. 카이제곱검정, 카이스퀘어검정, 독립성 검정. 예를 들면, 집의 크기와 TV 크기과 관계가 있는지를 따져보는 것. 교차분석 검정의 목적은 두 변수 사이에 “관계가 있는지”를 알아보는 것이다. (3) 상관관계분석 변수 간의 상관관계(correlation)를 알아보는 것이다. 상관관계는 변수간의 연관성이다. 한 변수가 변화할때 다른 변수가 같은 방향으로 변화하는지, 반대 방향으로 변화하는지얼마만큼 변화하는지 변화의 강도와 방향을 나타나는 계수가 상관계수(r)이다. 상관계수는 -1부터 1 사이. 상관계수가 +-0.7 이상이면 높은 관계이다. (4) 회귀분석(regression analysis) 독립변수와 종속변수 간의 인과관계를 분석하는 통계적 방법을 회귀분석이라고 한다. 독립변수는 영향을 주는 변수이다. 종속변수는 영향을 받는 변수이다. 독립변수가 종속변수에 미치는 영향을 확률적으로 분석하는 것이 회귀분석이다. 독립변수가 1개이면 단순회귀분석, 2개 이상이면 다중회귀분석이다. 2. 통계 검정1) 가설(hypothesis) 가설은 어떤 현상을 설명하기 위해서 가정하는 명제이다. 가설은 귀무가설과 대립가설로 나뉜다. 귀무가설은 설정한가설이 맞을 확률이 극히 적어서 처음부터 기각될 것으로 예상되는가설이다. 귀무가설을 영가설이라고도 한다. 대립가설은 귀무가설이 기각될 경우 받아들여지는 가설이다. 대립가설은 연구자가 검정하고자 하는 가설이다. 2) 유의수준(significance level) 가설검정의 결과는 유의수준에 의해 결정된다. 유의수준은 귀무가설이 맞는데도 대립가설을 채택할 확률이다. 즉 오류를 범할 확률이다. 통계 분석에서는 p-value로 제시된다. p값이 0.01이면 오류를 범할 확률이 1%라는 의미다. 유의수준 5%는 오류를 5%까지 허용하게다는 의미다. 가설검정에서 인정하는 유의수준에는 5%, 1%, 0.1% 가 있다. 유의수준의 반대 개념은 신뢰수준(confidence level)이다. 유의수준이 5%라면, 신뢰수준은 95%이다. 3) 척도(scale) 명목척도, 서열척도, 등간척도, 비율척도 명목척도: 측정대상의 특성이나 범주를 구분하는 수치. ex) 운동선수의 번호,결혼 유무, 종교, 인종, 지역, 계절, 성별 서열척도: 측정대상의 등급순위를 나타내는 척도. ex) 계급, 사회계층, 자격등급 등간척도: 측정대상을 일정한 간격으로 구분한 척도. 서열뿐만 아니라 간격도 표시.ex) 온도, 학력, 시험점수 비율척도: 측정대상을 비율로 나타낼 수 있는 척도. ex) 연령, 무게. 3. 통계 분석 사례1) 두 집단의 평균 차이 검정 두 집단의 평균 차이를 분석할 때는 독립표본 t검정을 한다. R에서는 내장된 t.test() 함수를 쓴다. t.test()함수를 쓰는 방식은 2가지다. 방법 1. t.test(data=데이터세트, 종속변수(비교값)~독립변수(비교대상)) 방법 2. t.test(데이터세트$종속변수(비교값)~데이터세트$독립변수(비교대상)) 예제파일 mpg1.csv -&gt; 오토와 수동이 통계적으로 유의미한 차이가 있는지 판단 -귀무가설: auto와 manual의 cty 평균은 차이가 없다.-대립가설: auto와 manual의 cty 평균은 차이가 있다. 12345678910111213mpg1 &lt;- read.csv(&quot;mpg1.csv&quot;, stringsAsFactors = F)#t.test(data=mpg1, cty~trans) #t.test(mpg1$cty~mpg1$trans)도 같음# welchTwoSample t-test# data: ctybytrans# t = -4.5375, df=132.32, p-value = 1.263e-05 # 1.263/100000# alternativehypothesis: true difference in means is not equal to 0# 95 percent confidenceinterval:# -3.887311 -1.527033# sample estimates:# mean in group auto mean in group manual# 15.96815 18.67532 결론: cty 평균거리는 auto가 15.79마일, manual이 18.68마일이다. 유의수준(p)이 0.05보다 작아서 통계적으로 유의미한 차이가 있기 때문에 수동식의 평균이 자동식의 평균보다 2.7 마일 길다고 할 수 있다. 교차분석 평균의 차이가 아니라, 비율에 차이가 있는지를 검정한다. R에서는 chisq.test()함수로 한다. 귀무가설 : trans에 따라 drv의 차이가 없다. 대립가설 : trans에 따라 drv의 차이가 있다. 123#mpg1 &lt;- read.csv(&quot;solution/public_dataset/mpg1.csv&quot;, stringAsFactors = F)#table(mpg1$trans, mpg1$drv) #trans와 drv의 교차분석#prop.table(table(mpg1$trans, mpg1$drv), 1) # auto와 manual의 drv 비율분석 123456789101112131415161718# 방법1#chisq.test(mpg1$trans, mpg1$drv)# pearson's chi-squaredtest# data: mpg1$trans and mpg1$drv# X-squared = 3.1368, df = 2, p-value = 0.2084# 방법2#chisq.test(mpg1$trans, mpg1$drv)# pearson's chi-squaredtest# data: mpg1$trans and mpg1$drv# X-squared = 3.1368, df = 2, p-value = 0.2084# 방법3#summary(table(mpg1$trans, mpg1$drv))#Number of cases in table: 234 # 행의수#Number of factors: 2 #비교 범주의 수#Test for independence of all factors:# chiq = 3.1368, df = 2, p-value = 0.2084 유의수준(P-value)이 0.2084로 p&gt;0.05이다. 귀무가설 영역이므로 trans에 따라 drv에 차이가 있다고 할 수 없다. 3) 상관관계분석 상관관계분석은 R에 내장되어 있는 cor.test() 함수로 한다. 귀무가설 : cty와 hwy는 상관관계가 없다. 대립가설 : cty와 hwy는 상관관계가 있다. 123mpg1 &lt;- read.csv(&quot;mpg1.csv&quot;, stringsAsFactors = F)cor.test(mpg1$cty, mpg1$hwy) #상관관계분석 1234567891011## ## Pearson's product-moment correlation## ## data: mpg1$cty and mpg1$hwy## t = 49.585, df = 232, p-value &lt; 2.2e-16## alternative hypothesis: true correlation is not equal to 0## 95 percent confidence interval:## 0.9433129 0.9657663## sample estimates:## cor ## 0.9559159 p-value &lt;2.2e-16. 즉, 유의수준이 2.2/1016보다 작다. 따라서, 대립가설을 채택할 수 있다. 상관관계는 0.9559159이다. 매우 높은 수준이다. 결론 : cty와 hwy는 유의미하게 매우 높은 상관관계(r=0.96)에 있다.(p&lt;0.05) 4) 회귀분석(1) 단순회귀분석 단순회귀분석은 독립변수가 1개, 종속변수가 1개일 때 한다. 회귀분석의 변수는 독립변수와 종속변수가 모두 등간척도 또는 비율척도이어야 한다. 회귀분석은 R의 lm()함수로 한다. 방법은 세 가지다 12345678# 방법1# lm(data=데이터세트, 종속변수~독립변수)# 방법2# lm(종속변수 ~ 독립변수, data=데이터세트)# 방법3# lm(데이터세트$종속변수~데이터세트$독립변수) R에 있는 mtcars 데이터세트로 분석. 귀무가설 : disp는 mpg에 영향을 주지 않는다. 대립가설 : disp는 mpg에 영향을 준다. 12#help(mtcars)lm(data=mtcars, mpg~disp) # 방법1 1234567## ## Call:## lm(formula = mpg ~ disp, data = mtcars)## ## Coefficients:## (Intercept) disp ## 29.59985 -0.04122 disp의 계수(Coefficients)는 -0.04122이며, 절편은 29.59985이다. 단순회귀분석은 1차 함수를 구하는 것과 같다. mpg = 29.59985 - 0.04122 * disp 베타 = -0.04122 회귀분석에서 절편은 의미가 없다. 유의수준을 구해줘야 한다. lm()함수의 결과를 summary() 함수에 넣으면 유의수준을 비롯해서 상세한 회귀분석 결과를 알 수 있다. 123RA &lt;- lm(data=mtcars, mpg~disp) # 회귀분석 결과를 RA에 넣기summary(RA) # 상세한 분석 결과 출력 123456789101112131415161718## ## Call:## lm(formula = mpg ~ disp, data = mtcars)## ## Residuals:## Min 1Q Median 3Q Max ## -4.8922 -2.2022 -0.9631 1.6272 7.2305 ## ## Coefficients:## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 29.599855 1.229720 24.070 &lt; 2e-16 ***## disp -0.041215 0.004712 -8.747 9.38e-10 ***## ---## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1## ## Residual standard error: 3.251 on 30 degrees of freedom## Multiple R-squared: 0.7183, Adjusted R-squared: 0.709 ## F-statistic: 76.51 on 1 and 30 DF, p-value: 9.38e-10 p-value가 0.05보다 작으면 회귀모형이 적합하다고 해석한다. p-value = 9.38e-10 = 9.38/1000000000 이므로 회귀모형이 적합하다. 계수(Coefficients)에서 Estimate는 회귀계수(베타)를 의미한다. Pr(&gt;t)값은 유의수준을 의미한다. 9.38e-10이 0.05보다 작으므로 귀무가설을 기각하고, 대립가설을 채택할 수 있다. 9.38-10 옆에 ‘***’ 표시가 있다. ‘‘는 유의수준 0.001, ‘‘는 유의수준 0.01, ‘‘는 유의수준 0.05를 충족한다는 의미다. R-squared는 결정계수다. 회귀모델의 추정된 회귀식이 관측된 데이터를 설명하고 있는 비율을 계수로 나타낸 것이다. 결정계수는 상관계수(r)를 제곱한 수치이며 R^2로 표시한다. 결정계수는 0과 1 사이에 존재한다. 1에 가까울수록 추정된 회귀선을 충족하는 표본 데이터가 많아서 추정된 회귀선의 예측 정확도와 변수 관계 설명력이 높다는 것을 의미한다. 결정계수 0.7183은 높은 수준이다. Adjusted R-Squared는 수정된 결정계수다. 결정계수는 데이터와 독립변수가 많을수록 회귀식의 예측력과 무관하게 커지는 경향이 이어서 이를 보완한 결정계수이다. 연구 결과에서 수정된 결정계수를 밝히는 것이 일반적이다. 여기서 수정된 결정계수는 0.709 분석결과 : 회귀모형은 유의수준 p &lt;0.001에서 적합하며, 회귀식의 수정된 결정계수는 0.709이다. 배기량(disp)이 연비(mpg)에 미치는 회귀계수(베타)는 유의수준 p&lt;0.001에서 -0.04이다. (2) 다중회귀분석 다중회귀분석은 종속변수에 영향을 주는 독립변수가 복수일 때 분석하는 방식이다. 다중회귀분석에서는 독립변수들을 ‘+’ 기호로 연결한다. 12345678# 방법1# lm(data=데이터세트, 종속변수~독립변수1+독립변수2+...)# 방법2# lm(종속변수 ~ 독립변수1+독립변수2+..., data=데이터세트)# 방법3#lm(데이터세트$종속변수 ~ 데이터세트$독립변수1+데이터세트$독립변수2+...) mtcars 데이터로 실습. mpg에는 disp(배기량) 이외에도 hp(마력)와 wt(중량)가 영향을 미칠 수 있다. 1lm(data=mtcars, mpg~disp+hp+wt) # 방법1 1234567## ## Call:## lm(formula = mpg ~ disp + hp + wt, data = mtcars)## ## Coefficients:## (Intercept) disp hp wt ## 37.105505 -0.000937 -0.031157 -3.800891 mpg = 37.105505 - 0.000937 * disp - 0.031157 * hp - 3.800891 * wt summary() 함수로 상세결과 확인한다. 123RA &lt;- lm(data=mtcars, mpg~disp+hp+wt) # 회귀분석 결과를 RA에 넣기summary(RA) 1234567891011121314151617181920## ## Call:## lm(formula = mpg ~ disp + hp + wt, data = mtcars)## ## Residuals:## Min 1Q Median 3Q Max ## -3.891 -1.640 -0.172 1.061 5.861 ## ## Coefficients:## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 37.105505 2.110815 17.579 &lt; 2e-16 ***## disp -0.000937 0.010350 -0.091 0.92851 ## hp -0.031157 0.011436 -2.724 0.01097 * ## wt -3.800891 1.066191 -3.565 0.00133 ** ## ---## Signif. codes: 0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1## ## Residual standard error: 2.639 on 28 degrees of freedom## Multiple R-squared: 0.8268, Adjusted R-squared: 0.8083 ## F-statistic: 44.57 on 3 and 28 DF, p-value: 8.65e-11 p값은 8.65e-11로 유의수준 0.001보다 작아 회귀모형은 적합하다. disp의 계수는 -0.000937 hp의 계수는 -0.031157 wt의 계수는 -3.800891 Pr(&gt;t)를 보면 disp의 유의수준은 0.92851로 허용되지 않는다. 마찬가지로 hp의 유의수준은 0.01097로 허용된다. wt의 유의수준은 0.00133으로 허용된다. 단순회귀분석에서는 disp가 영향을 주었는데, 다중회귀분석에서는 영향을 주지 않는다. 수정된 결정계수는 0.8083으로 높아서 회귀모델의 설명력이 높다. 결론 : 회귀모형은 유의수준 p &lt; 0.001에서 적합하며, 회귀식의 수정된 결정계수는 0.81이다. 3개 독립변수가 연비에 미치는 회귀계수(베타)는 hp가 -0.03(p&lt;0.05), wt가 -3.80(p&lt;0.01)이었고, disp는 없었다.","link":"/2022/03/15/ch08-2-/"},{"title":"아나콘다 설치","text":"아나콘다 설치웹사이트 주소 : https://www.anaconda.com/products/individual (작성방식 예시) 깃허브에서 R_edu 프로젝트를 다운로드 받는다. 1$ git clone 주소 여기서 다운로드 받는거다/images/source/images/ananconda_install 설치후 아나콘다 네이게이토 쥬피터 랩 런치 → AI폴더 → 01.ipynb 파일 생성","link":"/2022/03/15/ananconda_install/"},{"title":"파이참 설치","text":"파이참 설치 구글에 파이참 검색 셋업 실행 시스템 환경 변수 편집 /images/pychamsource/images/pycham 1~5줄이 있는지 확인해야 한다. 저게 있으려면 셋업 실행할 때 박스칸을 체크해줘야 한다. 만약 깜빡하고 안했으면 수기로 작성해줘야 한다. 환경 변수 편집 대화상자는 시스템 속성 대화상자에서 환경 변수를 클릭하면 된다.","link":"/2022/03/15/pycham/"},{"title":"colab 소개","text":"Colab이란? Colaboratory&amp;#40;줄여서 ‘Colab’이라고 함&amp;#41;을 통해 브라우저 내에서 Python 스크립트를 작성하고 실행할 수 있습니다. 구성이 필요하지 않음 GPU 무료 액세스 간편한 공유 학생이든, 데이터 과학자든, AI 연구원이든 Colab으로 업무를 더욱 간편하게 처리할 수 있습니다. Colab 소개 영상에서 자세한 내용을 확인하거나 아래에서 시작해 보세요. 시작하기지금 읽고 계신 문서는 정적 웹페이지가 아니라 코드를 작성하고 실행할 수 있는 대화형 환경인 Colab 메모장입니다. 예를 들어 다음은 값을 계산하여 변수로 저장하고 결과를 출력하는 간단한 Python 스크립트가 포함된 코드 셀입니다. 12seconds_in_a_day = 24 * 60 * 60seconds_in_a_day 86400 위 셀의 코드를 실행하려면 셀을 클릭하여 선택한 후 코드 왼쪽의 실행 버튼을 누르거나 단축키 ‘Command/Ctrl+Enter’를 사용하세요. 셀을 클릭하면 코드 수정을 바로 시작할 수 있습니다. 특정 셀에서 정의한 변수를 나중에 다른 셀에서 사용할 수 있습니다. 12seconds_in_a_week = 7 * seconds_in_a_dayseconds_in_a_week 604800 Colab 메모장을 사용하면 실행 코드와 서식 있는 텍스트를 이미지, HTML, LaTeX 등과 함께 하나의 문서로 통합할 수 있습니다. Colab 메모장을 만들면 Google Drive 계정에 저장됩니다. Colab 메모장을 간편하게 공유하여 동료나 친구들이 댓글을 달거나 수정하도록 할 수 있습니다. 자세히 알아보려면 Colab 개요를 참조하세요. 새 Colab 메모장을 만들려면 위의 파일 메뉴를 사용하거나 다음 링크로 이동하세요. 새 Colab 메모장 만들기 Colab 메모장은 Colab에서 호스팅하는 Jupyter 메모장입니다. Jupyter 프로젝트에 관해 자세히 알아보려면 jupyter.org를 참조하세요. 데이터 과학Colab을 통해 인기 있는 Python 라이브러리를 최대한 활용하여 데이터를 분석하고 시각화할 수 있습니다. 아래 코드 셀에서는 Numpy를 사용하여 임의의 데이터를 생성하고 매트플롯립으로 이를 시각화합니다. 셀을 클릭하면 코드 수정을 바로 시작할 수 있습니다. 1234567891011import numpy as npfrom matplotlib import pyplot as pltys = 200 + np.random.randn(100)x = [x for x in range(len(ys))]plt.plot(x, ys, '-')plt.fill_between(x, ys, 195, where=(ys &gt; 195), facecolor='g', alpha=0.6)plt.title(&quot;Sample Visualization&quot;)plt.show() Google Drive 계정에서 스프레드시트를 비롯한 데이터를 Colab 메모장으로 가져오거나 GitHub 등의 여러 다른 소스에서 데이터를 가져올 수 있습니다. Colab을 데이터 과학에 활용하는 방법과 데이터 가져오기에 관해 자세히 알아보려면 데이터 사용하기 아래 링크를 참조하세요. 머신러닝Colab을 사용하면 코드 몇 줄만으로 이미지 데이터세트를 가져오고, 이 데이터세트로 이미지 분류기를 학습시키며, 모델을 평가할 수 있습니다. Colab 메모장은 Google 클라우드 서버에서 코드를 실행하므로 사용 중인 컴퓨터의 성능과 관계없이 GPU 및 TPU를 포함한 Google 하드웨어의 성능을 활용할 수 있습니다. 브라우저만 있으면 사용 가능합니다. Colab은 다음과 같은 분야의 머신러닝 커뮤니티에서 널리 쓰이고 있습니다. TensorFlow 시작하기 신경망 개발 및 학습시키기 TPU로 실험하기 AI 연구 보급하기 튜토리얼 만들기 머신러닝 적용 사례를 보여 주는 Colab 메모장 샘플을 확인하려면 아래 머신러닝 예시를 참조하세요. 추가 리소스Colab에서 메모장 사용하기 Colaboratory 개요 Markdown 가이드 라이브러리 가져오기 및 종속 항목 설치하기 GitHub에서 노트 저장 및 로드하기 대화형 양식 대화형 위젯 Colab의 TensorFlow 2 데이터로 작업하기 데이터 로드: 드라이브, 스프레드시트, Google Cloud Storage 차트: 데이터 시각화하기 BigQuery 시작하기 머신러닝 단기집중과정다음은 Google 온라인 머신러닝 과정에서 가져온 일부 메모장입니다. 전체 과정 웹사이트에서 자세한 내용을 확인하세요. Pandas DataFrame 소개 합성 데이터를 사용하는 tf.keras 선형 회귀 가속 하드웨어 사용하기 GPU를 사용한 TensorFlow TPU를 사용한 TensorFlow 추천 예시 NeMo Voice Swap: Nvidia의 NeMo 대화형 AI 툴킷을 사용하여 오디오 파일의 음성을 컴퓨터에서 생성된 음성으로 변환하세요. 이미지 분류기 재훈련: 사전에 훈련된 이미지 분류기를 기반으로 꽃을 분류하기 위한 Keras 모델을 구축합니다. 텍스트 분류: IMDB 영화 리뷰를 긍정적인 리뷰 또는 부정적인 리뷰로 분류합니다. 스타일 트랜스퍼: 딥 러닝을 사용하여 이미지 간에 스타일을 전이시킵니다. Multilingual Universal Sentence Encoder Q&amp;A: 머신러닝 모델을 사용하여 SQuAD 데이터 세트의 질문에 답변합니다. 동영상 보간 유형: 동영상에서 첫 프레임과 마지막 프레임 사이에 발생한 내용을 예측합니다.","link":"/2022/03/14/colab_intro/"},{"title":"파이썬 기초 문법","text":"Hello World1print(&quot;Hello, World!&quot;) Hello, World! 주석 처리 코드 작업 시, 특정 코드에 대해 설명 사용자 정의 함수 작성 시, 클래스 작성 시..(도움말 작성..) 123456# 한 줄 주석 처리&quot;&quot;&quot;여러 줄 주석 처리 시 (큰따옴표도 가능, 통일만 되면)&quot;&quot;&quot;print(&quot;Hello&quot;) Hello 변수 ( Scalar) 객체(object)로 구현이 됨 하나의 자료형(Type)을 가진다. (이것만 기억!) 클래스로 정의가 됨. 다양한 함수들이 존재 함. int int 정수를 표현하는 데 사용함. 12345678# 데이터 전처리...# 데이터 전처리를 잘해야! 분석도 잘함. 예측 모형도 잘 만듬.# 데이터 전처리를 잘하기 위해서는 기초문법이 중요함.num_int = 1print(num_int)print(type(num_int)) 1 &lt;class 'int'&gt; float 실수를 표현하는데 사용한다. 123num_float = 0.2print(num_float)print(type(num_float)) 0.2 &lt;class 'float'&gt; bool True와 False로 나타내는 Boolean 값을 표현하는 데 사용한다. 1234bool_true = Trueprint(bool_true)print(type(bool_true)) True &lt;class 'bool'&gt; None Null을 나타내는 자료형으로 None이라는 한 가지 값만 가집니다. 123none_x = Noneprint(none_x)print(type(none_x)) None &lt;class 'NoneType'&gt; 사칙연산 정수형 사칙 연산 123456789a = 13b = 47print('a + b = ', a + b)print(a - b )print(a * b)print(a / b) # 실수형을 반환한다!!!print(a // b) # 나머지는 버린다.print(a % b) # 나머지만 가져온다.print(a ** b) # a를 b제곱한다. a + b = 60 -34 611 0.2765957446808511 0 13 22664052024539238871968220999332552715703774239747717 실수형 사칙연산123456789a = 13.0b = 47.0print('a + b = ', a + b)print(a - b )print(a * b)print(a / b) # 실수형을 반환한다!!!print(a // b) # 나머지는 버린다.print(a % b) # 나머지만 가져온다.print(a ** b) # a를 b제곱한다. a + b = 60.0 -34.0 611.0 0.2765957446808511 0.0 13.0 2.2664052024539239e+52 논리형 연산자 Bool 형은 True와 False 값으로 정의 AND / OR 123456789101112131415x = 5 &gt; 4# print(x)y = 3 &gt; 4# print(y)print(x and x)print(x and y)print(y and x)print(y and y)print(&quot;----&quot;)print(x or x)print(x or y)print(y or x)print(y or y) True False False False ---- True True True False 비교 연산자 부등호를 의미합니다. 비교 연산자를 True와 False값을 도출 논리 &amp; 비교 연산자 응용12var = input(&quot;입력하여 주세요..&quot;)print(type(var)) 입력하여 주세요123 &lt;class 'str'&gt; input은 문자열로 만들어버린다. 형변환을 해준다. 문자열, 정수, 실수 등등등 12var = int(&quot;1&quot;)print(type(var)) &lt;class 'int'&gt; 12var = int(input(&quot;숫자를 입력하여 주세요&quot;))print(type(var)) 숫자를 입력하여 주세요12345 &lt;class 'int'&gt; 123456789num1 = int(input(&quot;숫자를 입력하여 주세요...&quot;)) # 10num2 = int(input(&quot;숫자를 입력하여 주세요...&quot;)) # 3num3 = int(input(&quot;숫자를 입력하여 주세요...&quot;)) # 5num4 = int(input(&quot;숫자를 입력하여 주세요...&quot;)) # 7var1 = num1 &gt;= num2 # Truevar2 = num3 &lt; num4 # Trueprint(var1 and var2)print(var1 or var2) 숫자를 입력하여 주세요...10 숫자를 입력하여 주세요...3 숫자를 입력하여 주세요...5 숫자를 입력하여 주세요...7 True True 변수 (Non Scalar) 문자열을 입력 12print(&quot;'Hello, World!'&quot;)print('&quot;Hello, World!&quot;') 'Hello, World!' &quot;Hello, World!&quot; 1print(&quot;Hello world&quot;) Hello world 섞이면 안 된다. string 연산자 덧셈 연산자를 써보자. 1234str1 = &quot;Hello &quot;str2 = &quot;World! &quot;print(str1 + str2) Hello World! 곱셈 연산자를 사용해본다. 12greeting = str1 + str2print(greeting * 4) Hello World! Hello World! Hello World! Hello World! Indexing 문자열 인덱싱은 각각의 문자열 안에서 범위를 지정하여 특정 문자를 추출한다. 123greeting = &quot;Hello Kaggle!&quot;print(greeting[6])print(greeting[10]) K l 0부터 시작해서 6번째가 “K”이다. 공백도 포함해서 슬라이싱 범위를 지정하고 데이터를 가져온다. 1234567greetingprint(greeting[:])print(greeting[6:])print(greeting[:6])print(greeting[3:8]) # 끝은 n-1이 범위로 지정된다.print(greeting[0:9:2]) # 여기서 2는 두 칸씩 뛰라는 소리 Hello Kaggle! Kaggle! Hello lo Ka HloKg 1# greeting[13] # 스트링 인덱스가 범위 밖에 있다는 에러 메세지 문자열을 바꾸려면 바꾸고 싶은 부분을 기준으로 나누고 원하는 문자를 삽입한다. 1234a = &quot;pithon&quot;a[:1]a[2:]a[:1] + 'y' + a[2:] 'python' 문자열 포매팅 문자열 안의 특정한 값을 바꿔야 할 경우가 있을 때 사용하는 기법. 12&quot;I eat %d apples.&quot; % 3 'I eat five apples.' 1&quot;I eat %s apples.&quot; % &quot;five&quot; 'I eat five apples.' 숫자를 넣기 위해서는 %d 문자열을 넣기 위해서는 %s 12number = 3&quot;I eat %d apples.&quot; % number 'I eat 3 apples.' 숫자를 바로 대입하나 위 처럼 숫자 값을 나타내는 변수를 대입하나 결과는 같다. 123number = 10day = &quot;three&quot;&quot;I ate %d apples. so I was sick for %s days.&quot; %(number, day) 'I ate 10 apples. so I was sick for three days.' 위 처럼 2개 이상의 값을 넣으려면 마지막 % 다음 괄호 안에 콤마로 구분하여 각각의 값을 넣어 주면 된다. 문자열 포맷 코드 정수와 문자열 외에도 다양한 것을 대이할 수 있다. %s 는 문자열 %c 는 문자 1개(character) %d 는 정수(integer) %f 는 부동소수(floating-point) %o 는 8진수 %x 는 16진수 %% 는 Literal % (문자 % 자체) 12&quot;I have %s apples.&quot; % 3 'I have 3 apples.' 1&quot;rate is %s&quot; % 2.345 'rate is 2.345' 흥미롭게도 %s 포맷 코드는 어떤 형태의 값이든 변환해 넣을 수 있다. 왜냐하면 % 뒤에 있는 값을 문자열로 바꾸기 때문이다. 포매팅 연산자 %d와 %를 같이 쓸때는 %%를 쓴다.12&quot;Error is %d%%.&quot; % 98# %d%로 쓰면 'incomplete format'이란 에러가 뜬다. 'Error is 98%.' 포맷 코드와 숫자 함께 사용하기 포맷 코드를 숫자와 함께 사용하면 더욱 유용하다 정렬과 공백 1&quot;%10s&quot; % &quot;hi&quot; ' hi' %10s는 전체 길이가 10개인 문자열 공간에서 대입되는 값을 오른쪽으로 정렬하고 그 앞의 나머지는 공백으로 남겨 두라는 의미다. 1&quot;%-10sjane&quot; % 'hi' 'hi jane' hi를 왼쪽으로 정렬하고 나머지는 공백으로 채웠음을 볼 수 있다. 소수점 표현하기 1&quot;%0.4f&quot; % 3.42134234 '3.4213' 3.42134234를 소수점 네 번째 자리까지만 나타내고 싶은 경우에는 위와 같이 사용한다. ‘.’ 뒤의 숫자 4는 소수점 뒤에 나올 숫자의 개수를 의미한다. 1&quot;%10.4f&quot; %3.42134234 ' 3.4213' 위 예는 숫자 3.42134234를 소수점 네 번째 자리까지만 표시하고 전체 길이가 10개인 문자열 공간에서 오른쪽으로 정렬하는 예를 보여준다. format 함수를 사용한 포맷팅 문자열의 format 함수를 사용하면 좀 더 발전된 스타일로 문자열 포맷을 지정할 수 있다. 1&quot;I eat {0} apples&quot;.format(3) 'I eat 3 apples' {0} 부분이 숫자 3으로 바뀌었다. 12number = 3&quot;I eat {0} apples&quot;.format(number) 'I eat 3 apples' {0} 항목이 number 변수 값인 3으로 바뀌었다. 123number = 10day = &quot;three&quot;&quot;I ate {0} apples. so I was sick for {1} days.&quot;.format(number, day) 'I ate 10 apples. so I was sick for three days.' 2개 이상의 값을 넣을 경우 문자열의 {0}, {1}과 같은 인덱스 항목이 format 함수의 입력값으로 순서에 맞게 바뀐다. 1&quot;I ate {number} apples. so I was sick for {day} days.&quot;.format(number=10, day=3) 'I ate 10 apples. so I was sick for 3 days.' name=value와 같은 형태의 입력값이 있어야만 한다. 1&quot;I ate {0} apples. so I was sick for {day} days.&quot;.format(10, day=3) 'I ate 10 apples. so I was sick for 3 days.' 위와 같이 인덱스 항목과 name=value 형태를 혼용하는 것도 가능하다. 1&quot;{0:&lt;10}&quot;.format(&quot;hi&quot;) 'hi ' :&lt;10 표현식을 사용하면 치환되는 문자열을 왼쪽으로 정렬하고 문자열의 총 자릿수를 10으로 맞출 수 있다. 1&quot;{0:&gt;10}&quot;.format(&quot;hi&quot;) ' hi' 위 예문은 오른쪽 정렬 1&quot;{0:^10}&quot;.format(&quot;hi&quot;) ' hi ' 가운데 정렬은 :^ 기호를 사용한다. 1&quot;{0:=^10}&quot;.format(&quot;hi&quot;) '====hi====' 정렬할 때 공백 대신 지정한 문자 값으로 채워 넣는 것도 가능하다. 채워 넣을 문자 값은 정렬 문자 &lt;, &gt;, ^ 바로 앞에 넣어야 한다. 1&quot;{0:!&lt;10}&quot;.format(&quot;hi&quot;) 'hi!!!!!!!!' 12y = 3.42134234&quot;{0:0.4f}&quot;.format(y) '3.4213' 위 예는 format 함수를 사용해 소수점을 4자리까지만 표현하는 방법을 보여 준다. 1&quot;{0:10.4f}&quot;.format(y) ' 3.4213' 위 예는 자릿수를 10으로 맞춰준 것이다. f 문자열 포매팅 다음과 같이 문자열 앞에 f 접두사를 붙이면 f 문자열 포매팅 기능을 사용할 수 있다. f 문자열 포매팅은 표현식(변수와 +, -같은 수식을 함께 사용하는 것)을 지원한다. 123name = '홍길동'age = 30f'나의 이름은 {name}입니다. 나이는 {age}입니다.' '나의 이름은 홍길동입니다. 나이는 30입니다.' 12age = 30f'나는 내년이면 {age+1}살이 된다.' '나는 내년이면 31살이 된다.' 딕셔너리는 f 문자열 포매팅에서 다음과 같이 사용할 수 있다. 12d = {'name':'홍길동', 'age':30}f'나의 이름은 {d[&quot;name&quot;]}입니다. 나이는 {d[&quot;age&quot;]}입니다.' '나의 이름은 홍길동입니다. 나이는 30입니다.' 정렬은 다음과 같이 할 수 있다. 1234f'{&quot;hi&quot;:&lt;10}' #왼쪽 정렬f'{&quot;hi&quot;:&gt;10}' #오른쪽 정렬f'{&quot;hi&quot;:^10}' #가운데 정렬 ' hi ' 공백 채우기 1f'{&quot;hi&quot;:=^10}' '====hi====' 소수점 표현 12y = 3.42134234f'{y:0.4f}' '3.4213' 문자열 관련 함수들 문자열 내장 함수 count함수 문자 개수 세기 12a = &quot;hobby&quot;a.count('b') #b의 개수를 돌려준다. 2 find함수 위치 알려주기1 123a = &quot;python is the best choice&quot;a.find('b') # 14a.find('k') # -1 -1 문자열 중 문자 b가 처음으로 나온 위치가 14라는 뜻 만약 k처럼 문자가 없으면 -1을 반환한다. index함수 위치 알려주기2 12a = &quot;Life is too short&quot;a.index('t') 8 find함수와 마찬가지로 문자 t가 맨 처음으로 나온 위치를 반환한다. 만약 찾는 문자열이 존재하지 않는다면 오류를 발생시킨다. join 함수 문자열 삽입 1&quot;,&quot;.join('abcd') 'a,b,c,d' abcd 문자열의 각각 ‘,’를 삽입한다. upper 함수 / lower 함수 소문자를 대문자로 바꾸기 대문자를 소문자로 바꾸기 12a = &quot;hi&quot;a.upper() 'HI' lstrip 함수 / rstrip 함수 / strip 함수 왼쪽 공백 지우기 오른쪽 공백 지우기 양쪽 공백 지우기 12a = &quot; hi &quot;a.lstrip() 'hi ' replace 함수 문자열 바꾸기 12a = &quot;Life is too short&quot;a.replace(&quot;Life&quot;, &quot;Your leg&quot;) #a.replace(바꾸고 싶은 문자열, 바꿀 문자열) 'Your leg is too short' split 함수 문자열 나누기 1234a = &quot;Life is too short&quot;a.split()b = &quot;a:b:c:d&quot;b.split(':') ['a', 'b', 'c', 'd'] a.split() 처럼 괄호안에 아무 값도 넣어 주지 않으면 공백을 기준으로 문자열을 나눈다. 만약 b.split(‘:’) 처럼 괄호 안에 특정 값이 있을 경우에는 그걸 구분자로 한다. 리스트 시퀀스 데이터 타입 데이터에 순서가 존재하냐! 슬라이싱이 가능해야 함. 대괄호(‘[값1, 값2, 값3]’) 12345678910111213a = [] # 빈 리스트 생성a_func = list() # 빈 리스트 생성b = [1] # 숫자가 요소가 될 수 있다.c = ['apple'] # 문자열도 요소가 될 수 있다.d = [1, 2, ['apple']] # 리스트 안에 또 다른 리스트를 요소로 넣을 수 있다.print(a)print(a_func)print(b)print(c)print(d)print(type(d)) [] [] [1] ['apple'] [1, 2, ['apple']] &lt;class 'list'&gt; 리스트 슬라이싱123456789a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]# print(a)print(a[0]) print(a[6:])print(a[:5])print(a[3:5])print(a[4:7])print(a[2:8])print(a[1:9:3]) 1 [7, 8, 9, 10] [1, 2, 3, 4, 5] [4, 5] [5, 6, 7] [3, 4, 5, 6, 7, 8] [2, 5, 8] 12345678a = [[&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;], 1] # 중첩 리스트print(a[0])print(a[0][1])print(a[0][0][4]) # 애플의 eprint(a[0][0][-1]) # 애플의 eprint(a[0][2][2]) # 체리의 eprint(a[0][2][-4]) # 체리의 e ['apple', 'banana', 'cherry'] banana e e e e 1234a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]print(a[::-1]) # 역순print(a[::2]) [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] [1, 3, 5, 7, 9] 리스트 연산자1234567a = [&quot;john&quot;, &quot;evan&quot;]b = [&quot;alice&quot;, &quot;sarah&quot;]c = a + bprint(c)d = b + aprint(d) ['john', 'evan', 'alice', 'sarah'] ['alice', 'sarah', 'john', 'evan'] 1234c = a * 3d = b * 0print(&quot;a * 3 = &quot;, c)print(&quot;b * 0 = &quot;, d) a * 3 = ['john', 'evan', 'john', 'evan', 'john', 'evan'] b * 0 = [] 리스트 길이 구하기 리스트 길이를 구하기 위해서는 len 함수를 사용한다 12a = [1, 2, 3]len(a) 3 리스트 수정 및 삭제123a = [0, 1, 2]a[1] = &quot;b&quot;print(a) [0, 'b', 2] 리스트 값 추가하기123a = [100, 200, 300]a.append(400)print(a) [100, 200, 300, 400] a를 저장해주지 않았는데도 append메서드를 사용했더니 자동저장되었다. 파이썬에 이런게 은근 많다. 모두 알려고 하지 말고 만나는대로 습득하는 수밖에 없다. 12a.append([500, 600])print(a) # 원하는 답이 안 나옴 [100, 200, 300, 400, [500, 600]] 1234a = [100, 200, 300]a.extend([500, 600])print(a) [100, 200, 300, 500, 600] 1234a = [ 0, 1, 2]# a.insert(인덱스번호, 넣고자하는 값)a.insert(1, 100)print(a) [0, 100, 1, 2] 리스트 값 삭제하기12345a = [4, 3, 2, 1, &quot;A&quot;]a.remove(1) # 리스트에서 첫번째로 나오는 값을 삭제(인덱스 번호가 아니다)print(a)a.remove(&quot;A&quot;)print(a) [4, 3, 2, 'A'] [4, 3, 2] 1234567a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]del a[1] # 인덱스 번호print(a)del a[1:5]print(a) # 3, 4, 5, 6이 지워짐 [1, 3, 4, 5, 6, 7, 8, 9, 10] [1, 7, 8, 9, 10] pop 함수 리스트의 맨 마지막 요소를 돌려주고 그 요소는 삭제한다. 1234b = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]x = b.pop()print(x)print(b) d ['a', 'b', 'c'] 그 외 메서드12345a = [0, 1, 2, 3]print(a)a.clear()print(a) [0, 1, 2, 3] [] 123a = [&quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;]print(a.index(&quot;a&quot;))print(a.index(&quot;b&quot;)) 0 2 123456789a = [1, 4, 5, 2, 3]b = [1, 4, 5, 2, 3]a.sort()print(&quot;sort(): &quot;, a)# 내림차순, sort()b.sort(reverse=True)print(&quot;sort(reverse=True): &quot;, b) sort(): [1, 2, 3, 4, 5] sort(reverse=True): [5, 4, 3, 2, 1] 내림차순 같은 옵션을 알아내는 방법은 구글링이다. 12c = [4, 3, 2, 'a']# c.sort() reverse 함수 리스트 뒤집기 리스트를 역순으로 123a = ['a', 'b', 'c']a.reverse()print(a) ['c', 'b', 'a'] index 함수 위치 반환 12a = [1, 2, 3]a.index(3) # 3의 인덱스값은 2이다. 2 extend 리스트 확장 extend(x)에서 x에는 리스트만 올 수 있다. a.extend([4, 5])는 a += [4, 5]와 동일하다. 123456a = [1, 2, 3]a.extend([4, 5])print(a)b = [6, 7]a.extend(b)print(a) [1, 2, 3, 4, 5] [1, 2, 3, 4, 5, 6, 7] 튜플 List와 비슷하다. 슬라이싱, 인덱싱 등등 (vs 리스트) : 튜플은 수정 삭제가 안된다. 123456tuple1 = (0) # 끝에 콤마(,)를 붙이지 않을 때 --&gt; inttuple2 = (0,) # 끝에 콤마 붙일 때 --&gt; tupletuple3 = 0, 1, 2 # 괄호를 생략해도 무방하다.print(type(tuple1)) print(type(tuple2)) print(type(tuple3)) &lt;class 'int'&gt; &lt;class 'tuple'&gt; &lt;class 'tuple'&gt; 12345a = (0, 1, 2, 3, 'a')print(type(a))# del a[4] -&gt; 튜플은 수정이 안된다.# a[1] = &quot;b&quot; -&gt; 튜플은 수정이 안된다. &lt;class 'tuple'&gt; 튜플 인덱싱 및 슬라이싱 하기1234a = (0, 1, 2, 3, 'a')print(a[1])print(a[3])print(a[4]) 1 3 a 더하기 곱셈 연산자 사용123456t1 = (0, 1, 2, 3)t2 = (4, 5, 6 ,7)print(t1 + t2)print(t1 * 3)print(t2 * 0) (0, 1, 2, 3, 4, 5, 6, 7) (0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3) () 딕셔너리 key-value값으로 나뉨. 123456789dict_01 = {'teacher' : 'evan', 'class' : 601, 'student' : 24, '학생이름' : ['A', 'Z']}print(dict_01)print(dict_01['teacher'])print(dict_01['class'])print(dict_01['학생이름'])# print(dict_01['선생님']) {'teacher': 'evan', 'class': 601, 'student': 24, '학생이름': ['A', 'Z']} evan 601 ['A', 'Z'] 1print(dict_01.keys()) dict_keys(['teacher', 'class', 'student', '학생이름']) 1print(dict_01.values()) dict_values(['evan', 601, 24, ['A', 'Z']]) 1dict_01.items() # 튜플 형태로 묶이더라 dict_items([('teacher', 'evan'), ('class', 601), ('student', 24), ('학생이름', ['A', 'Z'])]) 123456print(dict_01.get(&quot;teacher&quot;)) # get메서드print(dict_01.get(&quot;선생님&quot;))print(dict_01.get(&quot;class&quot;))# print(dict_01['선생님']) # get을 써주는 이유. 키 값이 없을 때 None을 떨궈주면서 다음 줄을 실행시켜준다.print(dict_01.get(&quot;students&quot;))print(dict_01.get(&quot;선생님&quot;, &quot;없어용&quot;)) # None말고 지정한 값 떨궈주는 방법 evan None 601 None 없어용 조건문 &amp; 반복문조건문 일상에서 조건문 언제쓸까요? 12345weather = &quot;비&quot;if weather == &quot;비&quot;: # 조건식 True가 나오면 print(&quot;우산을 가져간다.&quot;)else: print(&quot;우산을 가져가지 않는다.&quot;) 우산을 가져간다. 등급표를 만들어보자 60점 이상 합격 / 그외는 불합격 숫자는 아무거나 써도 상관없음 12345score = 61if score &gt;= 60 : print(&quot;합격&quot;)else: print(&quot;불합격&quot;) 합격 123456score = int(input(&quot;점수를 입력하세요...&quot;)) # input은 문자열로 인식을 하니까 정수형으로 형변환if score &gt;= 60 : print(&quot;합격&quot;)else: print(&quot;불합격&quot;) 점수를 입력하세요...70 합격 등급으로 나눠보자 90점 이상은 A등급 80점 이상은 B등급 나머지는 F등급 if-elif-else 12345678score = int(input(&quot;점수를 입력해 주세요: &quot;))if score &gt;= 90: print(&quot;A등급&quot;)elif score &gt;= 80: print(&quot;B등급&quot;)else: print(&quot;F등급&quot;) 점수를 입력해 주세요: 95 A등급 반복문 안녕하세요! 10번 반복하세요. 12345678910print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;)print(&quot;안녕하세요!&quot;) 2번째 과제 : 안녕하세요! 789256번 반복하세요. 123# 789... 뭐시기 반복하기for i in range(3): print(i + 1, &quot;안녕하세요!&quot;) 1 안녕하세요! 2 안녕하세요! 3 안녕하세요! 12345count = range(3)print(count)for n in count: print(n) range(0, 3) 0 1 2 123456789count = range(50)print(count)for n in count: print(str(n + 1) + &quot;번째&quot;) if (n + 1) == 5: print(&quot;그만&quot;) break print(&quot;슈팅&quot;) range(0, 50) 1번째 슈팅 2번째 슈팅 3번째 슈팅 4번째 슈팅 5번째 그만 123456a = &quot;hello&quot;for x in a: if x == &quot;l&quot;: break print(x) h e 반복문 작성 방식은 다양하다. zip, range, enumerate, len 등등 123alphabets = ['A', 'B', 'c']for index, value in enumerate(alphabets): print(index, value) 0 A 1 B 2 c","link":"/2022/03/21/basic_grammer/"},{"title":"파이썬 기초 문법 2","text":"기초 문법 리뷰123456789101112# 리스트book_list = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]# append, extend, insert, remove, pop, etc# 튜플book_tuple = (&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)# 수정 삭제가 불가능하다# 딕셔너리book_dictionary = {&quot;책 제목&quot; : [&quot;오베&quot;, &quot;셜록&quot;, &quot;파운데이션] &quot;출판년도&quot; : [2001, ]}#keys(), values(), items(), get() 조건문 &amp; 반복문123456if True: print(&quot;코드 실행&quot;) # 들여쓰기 안하면 에러가 난다.elif True: print(&quot;코드 실행&quot;)else: print(&quot;코드 실행&quot;) for문for문의 기본 구조123for 변수 in 리스트(또는 튜플, 문자열): 수행할 문장1 수행할 문장2 전형적인 for문123test_list = ['one', 'two', 'three']for i in test_list: print(i) one two three 다양한 for문의 사용123a = [(1,2), (3,4), (5,6)]for (first, last) in a: print(first + last) 3 7 11 위 예는 a 리스트의 요솟값이 튜플이기 때문에 각각의 요소가 자동으로 변수에 대입된다. for문의 응용123456789marks = [90, 25, 67, 45, 80]number = 0for mark in marks: number = number + 1 if mark &gt;= 60: print(&quot;%d번 학생은 합격입니다.&quot; % number) else: print(&quot;%d번 학생은 불합격입니다.&quot; % number) 1번 학생은 합격입니다. 2번 학생은 불합격입니다. 3번 학생은 합격입니다. 4번 학생은 불합격입니다. 5번 학생은 합격입니다. for문과 continue while문 처럼 continue 사용가능하다. 즉 for문 맨 처음으로 돌아가게 된다. 12345678marks = [90, 25, 67, 45, 80]number = 0for mark in marks: number = number + 1 if mark &lt; 60: continue print(&quot;%d번 학생 축하합니다. 합격입니다. &quot; % number) 1번 학생 축하합니다. 합격입니다. 3번 학생 축하합니다. 합격입니다. 5번 학생 축하합니다. 합격입니다. 12for i in range(3): print(i+1, &quot;hel&quot;) 1 hel 2 hel 3 hel 123book_list = [&quot;프로그래밍 R&quot;, &quot;혼자 공부하는 머신러닝&quot;]for book in book_list: print(book) 프로그래밍 R 혼자 공부하는 머신러닝 123strings01 = &quot;Hello World&quot;for char in strings01: print(char) H e l l o W o r l d 123num_tuple = (1, 2, 3, 4) # 튜플도 동일for num in num_tuple: print(num) 1 2 3 4 123num_dict = {&quot;A&quot;: 1, &quot;B&quot; : 2} # 딕셔너리는 뭔가 불안정for num in num_dict: print(num) A B 반복문의 필요성12345678910111213product_name = [&quot;요구르트&quot;, &quot;우유&quot;]prices = [1000, 1500]quantities = [5, 3]name = product_name[0]sales = prices[0] * quantities[0]print(name + &quot;의 매출액은 &quot; + str(sales) + &quot;원이다.&quot;)name = product_name[1]sales = prices[1] * quantities[1]print(name + &quot;의 매출액은 &quot; + str(sales) + &quot;원이다.&quot;) 요구르트의 매출액은 5000원이다. 우유의 매출액은 4500원이다. 반복문이 필요하다! 1234567891011product_name = [&quot;요구르트&quot;, &quot;우유&quot;]prices = [1000, 1500]quantities = [5, 3]for i in range(len(product_name)): name = product_name[i] sales = prices[i] * quantities[i] print(name + &quot;의 매출액은 &quot; + str(sales) + &quot;원이다.&quot;) # print도 반복문 안에 있음을 기억하자(들여쓰기) 요구르트의 매출액은 5000원이다. 우유의 매출액은 4500원이다. 만약, 항목의 개수를 모른다면??? 모르는게 생기면 구글링을 해야한다 구글 검색 엔진: how to count list in python 그렇게 해서 len함수를 찾아 냈다. 반복문을 바로 작성할 필요가 없다. 그러면 헷갈린다. 하나씩 직접해보고, 패턴을 발견하고, 그리고 짜는 것이다. while문 얘도 반복문이다 조건식이 들어가는 것이 포인트(vs. for-loop는 정해진 범위가 포인트) 12345count = 0 # 처음에 상수가 들어가야 한다.while count &lt; 5: # 여기 조건식이 True가 나와야 한다. False가 나오면 실행 중지. count = count + 1 print(count, &quot;안녕하세요..&quot;)print(&quot;5를 초과했군요!&quot;) 1 안녕하세요.. 2 안녕하세요.. 3 안녕하세요.. 4 안녕하세요.. 5 안녕하세요.. 5를 초과했군요! 조건식이 만족할 때까지 계속 실행되다가 만족하지 않을 때 while문은 끝이 난다. 두 번째 방식 : 숫자를 차감하면서 반복하는 방식 12345count = 3 while count &gt; 0: count = count - 1 print(count, &quot;안녕하세요..&quot;)print(&quot;0 미만 이군요!&quot;) 2 안녕하세요.. 1 안녕하세요.. 0 안녕하세요.. 0 미만 이군요! “열 번 찍어 안 넘어가는 나무 없다”123456treeHit = 0while treeHit &lt; 10: treeHit = treeHit +1 # treeHit += 1 print(&quot;나무를 %d번 찍었습니다.&quot; % treeHit) if treeHit == 10: print(&quot;나무 넘어갑니다.&quot;) 나무를 1번 찍었습니다. 나무를 2번 찍었습니다. 나무를 3번 찍었습니다. 나무를 4번 찍었습니다. 나무를 5번 찍었습니다. 나무를 6번 찍었습니다. 나무를 7번 찍었습니다. 나무를 8번 찍었습니다. 나무를 9번 찍었습니다. 나무를 10번 찍었습니다. 나무 넘어갑니다. while문 강제로 빠져나가기(break) 커피 자판기 예 123456789coffee = 10money = 300while money: print(&quot;돈을 받았으니 커피를 줍니다.&quot;) coffee = coffee -1 print(&quot;남은 커피의 양은 %d개입니다.&quot; % coffee) if coffee == 0: print(&quot;커피가 다 떨어졌습니다. 판매를 중지합니다.&quot;) break 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 9개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 8개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 7개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 6개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 5개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 4개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 3개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 2개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 1개입니다. 돈을 받았으니 커피를 줍니다. 남은 커피의 양은 0개입니다. 커피가 다 떨어졌습니다. 판매를 중지합니다. while문의 맨 처음으로 돌아가기(continue)12345a = 0while a &lt; 10: a = a + 1 if a % 2 == 0: continue # a가 짝수라면 print(a) 1 3 5 7 9 continue는 while문 맨 처음으로 돌아가게 한다.(조건문: a&lt;10) 개발자를 지향한다면, while문 공부를 좀 더 비중있게 다루는 게 좋다. 데이터 분석가를 지향한다면, while문을 쓸 일이 별로 없다. for-loop 공부를 좀 더 비중있게 하는 게 좋다. 사용자 정의 함수 (User-Defined Function) 이거 왜 쓸까? 클래스(Class)를 왜 쓸까? 코드의 반복성을 줄이기 위해서 사용하는 것이다. len() —&gt; 누군가가 만들었고, 우리는 그걸 그냥 쓰는 것이다. 리스트의 길이 구할 때 쓴다. 리스트의 전체 길이를 구하겠다!? -&gt; 1회성? 나만 쓰는가? 12345def 함수명(): # 코드 실행 return 값함수명() 123456789101112# 더하기 함수 만들기def add(a, b): c = a + b return cif __name__ == &quot;__main__&quot;: a = 1 b = 2 c = add(a, b) print(c) 3 123456# 빼기 함수 만들기def minu(a, b): c = a - b return cminu(1, 2) -1 123456# 곱하기 함수 만들기def multi(a, b): c = a * b return cmulti(1, 2) 2 123456# 나누기 함수 만들기def divis(a, b): c = a / b return cdivis(1, 2) 0.5 jupyter notebook, .ipynb 확장자명.py로 저장 (pycharm..) basic.py로 저장할 때, 예시 123456789101112# /user/local/bin/python# -*- coding: utf-8 -*-def divis(a, b): c = a / b return cif __name__ == &quot;__main__&quot;: a = 1 b = 2 c = divis(a, b) print(c) 파이썬 함수 주석 처리 docstring 작업 나중에 프로젝트할 때 필요할 것이다. 코드 작성 마지막 단계에서 필히 추가해야할 내용이다. 123456789101112131415161718192021# /user/local/bin/python# -*- coding: utf-8 -*-def temp(content, letter): &quot;&quot;&quot;content안에 있는 문자를 세는 함수입니다. Args: content(str) : 탐색 문자열 letter(str) : 찾을 문자열 Returns: int &quot;&quot;&quot; print(&quot;함수 테스트&quot;) cnt = len([char for char in content if char == letter]) return cntif __name__ == '__main__': help(temp) Help on function temp in module __main__: temp(content, letter) content안에 있는 문자를 세는 함수입니다. Args: content(str) : 탐색 문자열 letter(str) : 찾을 문자열 Returns: int 리스트 컴프리헨션 for-loop를 한 줄로 처리 리스트 안에 for-loop를 쓸 수 있다. 어렵다. 12345678910111213my_list = [[10], [20, 30]]# print(my_list)# 결과값 : [10, 20 ,30]으로 만들고 싶다.flattened_list = []for value_list in my_list: # print(value_list) for value in value_list: print(value) flattened_list.append(value)print(flattened_list) 10 20 30 [10, 20, 30] 123my_list = [[10], [20, 30]]flattened_list = [value for value_list in my_list for value in value_list]print(flattened_list) [10, 20, 30] 12345# 다른 예제letters = []for char in &quot;helloworld&quot;: letters.append(char)print(letters) ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd'] 12letters2 = [char for char in &quot;helloworld&quot;]print(letters2) ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd'] 사용자 정의 함수 다시1234567891011121314151617181920212223242526def mean_and_median(value_list): &quot;&quot;&quot;숫자 리스트의 요소들의 평균과 중간값을 구하는 코드를 작성해라 Args: value_list (iterable of int / float): A list of int numbers Returns: tuple(float, float) &quot;&quot;&quot; # 평균 mean = sum(value_list) / len(value_list) # 중간값 midpoint = int(len(value_list) / 2) if len(value_list) % 2 == 0: median = (value_list[midpoint - 1] + value_list[midpoint]) / 2 else: median = value_list[midpoint] return mean, medianif __name__ == &quot;__main__&quot;: value_list = [1, 1, 2, 2, 3, 4, 5] avg, median = mean_and_median(value_list) print(&quot;avg:&quot;, avg) print(&quot;median:&quot;, median) avg: 2.5714285714285716 median: 2 데코레이터, 변수명 immutable or mutable, context manager 등의 내용은 점프 투 파이썬에 없다. 파이썬 코딩 도장에 있다.","link":"/2022/03/22/basic_grammer_2/"},{"title":"파이썬 기초 문법 3","text":"클래스클래스를 만드는 목적! 코드의 간결화 코드를 재사용 여러 라이브러리 –&gt; 클래스로 구현이 됨 list 클래스, str 클래스 객체로 씀 변수명으로 정의! 여러 클래스들이 모여서 하나의 라이브러리가 됨. 장고 / 웹개발 / 머신러닝 / 시각화/ 데이터 전처리 어렵다. 그러나 왜 쓰는지를 기억해야 한다. 모든 웹개발은 클래스로 구현된다. 지금 단계에서 클래스를 구현하는건 말도 안 된다. 1234567891011121314151617class Person: # class 대문자소문자소문자~: # class attribute # 있어도 되고 없어도 되고 country = &quot;korean&quot; # instance attribute def __init__(self, name, age): # 무조건 있어야 함. self.name = name self.age = ageif __name__ == &quot;__main__&quot;: kim = Person(&quot;kim&quot;, 100) lee = Person(&quot;lee&quot;, 100) # access class attribute print(&quot;kim은 {}&quot;.format(kim.__class__.country)) print(&quot;lee은 {}&quot;.format(kim.__class__.country)) kim은 korean lee은 korean instance 메서드 생성 list.appen(), list.extend() 12345678910111213141516171819202122232425class Person: # class 대문자소문자소문자~: # class attribute # 있어도 되고 없어도 되고 country = &quot;korean&quot; # instance attribute def __init__(self, name, age): # 무조건 있어야 함. self.name = name self.age = age # instance method 정의 def singing(self, songtitle): return &quot;{} {}을 노래합니다.&quot;.format(self.name, songtitle)if __name__ == &quot;__main__&quot;: kim = Person(&quot;kim&quot;, 100) lee = Person(&quot;lee&quot;, 100) # access class attribute print(&quot;kim은 {}&quot;.format(kim.__class__.country)) print(&quot;lee은 {}&quot;.format(kim.__class__.country)) # call instance method print(kim.singing(&quot;A&quot;)) print(lee.singing(&quot;B&quot;)) kim은 korean lee은 korean kim A을 노래합니다. lee B을 노래합니다. 클래스 상속(inheritance) 부모님 유산… 부모님 집 (냉장고, 세탁기, TV, etc) # 부모 클래스 instance method, attribute 사용은 같이 함 여러분, 돈을 모음 개인 노트북 구매 ( 여러분 각자 방에 비치) # 자식 클래스 instance method, attribute 추가 확장 노트북은 내 거고, 추가 가전 제품을 구매해서 확장! 12345678910111213141516171819202122232425262728293031323334353637class Parent: # instance attribute # init constructor def __init__(self, name, age): self.name = name self.age = age # instance method 정의 def whoAmI(self): print(&quot;I am Parent!!&quot;) def singing(self, songtitle): return &quot;{} {}을 노래합니다.&quot;.format(self.name, songtitle) def dancing(self): return &quot;{} 현재 춤을 춥니다.&quot;.format(self.name)class Child(Parent): def __init__(self, name, age): # super() function super().__init__(name, age) # 지금이야 두 줄이지 원래는 엄청 긴 줄 print(&quot;Child Class is ON&quot;) def whoAmI(self): print(&quot;I am child&quot;) def studying(self): print(&quot;I am Fast Runner&quot;)if __name__ == &quot;__main__&quot;: child_kim = Child(&quot;kim&quot;, 15) parent_kim = Parent(&quot;kim&quot;, 45) print(child_kim.dancing()) # 자식은 춤을 춘다는 코드가 없는데 부모의 코드를 물려 받았다. print(child_kim.singing(&quot;연애&quot;)) # 마찬가지 # print(parent_kim.studying()) # AttributeError: 'Parent' object has no attribute 'studying' child_kim.whoAmI() parent_kim.whoAmI() Child Class is ON kim 현재 춤을 춥니다. kim 연애을 노래합니다. I am child I am Parent!! AttributeError: ‘Parent’ object has no attribute ‘studying’ Parent 클래스에 studying 속성이 없더라. 부모는 자식의 물건을 쓰지 않는다. 1234567891011121314151617181920212223class TV: def __init__(self): self.__maxprice = 500 def sell(self): print(&quot;Selling Price: {}&quot;.format(self.__maxprice)) def setMaxPrice(self, price): self.__maxprice = priceif __name__ == &quot;__main__&quot;: tv = TV() tv.sell() # change price # 안 바뀌는 코드의 예시 tv.__maxprice = 1000 tv.sell() # setMaxprice # 값을 바꿀 수 있다!? 외부의 입력값을 업데이트 할 수 있다! tv.setMaxPrice(1000) tv.sell() Selling Price: 500 Selling Price: 500 Selling Price: 1000 클래스 내부에 조건문 init constructor에 조건문을 써보자! 123456789101112131415161718192021222324252627282930313233class Employee: # init constructor # name, salary def __init__(self, name, salary = 0): self.name = name # 조건문 추가 if salary &gt; 0: self.salary = salary else: self.salary = 0 print(&quot;급여는 0원이 될 수 없다!. 다시 입력하셈!&quot;) def update_salary(self, amount): # self.salary = self.salary + amount self.salary += amount def weekly_salary(self): return self.salary / 7if __name__ == &quot;__main__&quot;: emp01 = Employee(&quot;hs&quot;, -50000) print(emp01.name) print(emp01.salary) # emp01.salary = emp01.salary + 1500 emp01.salary += 1500 print(emp01.salary) emp01.update_salary(3000) print(emp01.salary) weekly_salary = emp01.weekly_salary() print(weekly_salary) 급여는 0원이 될 수 없다!. 다시 입력하셈! hs 0 1500 4500 642.8571428571429 클래스 Docstring123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Person: &quot;&quot;&quot; 사람을 표현하는 클래스 ... Attributes ---------- name : str name of the person age : int age of the person Methods ---------- info(additional=&quot;&quot;): Prints the person's name and age &quot;&quot;&quot; def __init__(self, name, age): &quot;&quot;&quot; Constructs all the neccessary attributes for the person object Parameters ---------- name : str name of the person age : int age of the person &quot;&quot;&quot; self.name = name self.age = age def info(self, additional=None): &quot;&quot;&quot; 귀찮음... Parameters ---------- additional : str, optional more info to be displayed (Default is None) / A, B, C Returns ------- None &quot;&quot;&quot; print(f'My name is {self.name}. I am {self.age} years old. ' + additional)if __name__ == &quot;__main__&quot;: person = Person(&quot;Evan&quot;, age = 20) person.info(&quot;나의 직장은 00이야&quot;) help(Person) My name is Evan. I am 20 years old. 나의 직장은 00이야 Help on class Person in module __main__: class Person(builtins.object) | Person(name, age) | | 사람을 표현하는 클래스 | | ... | | Attributes | ---------- | name : str | name of the person | | age : int | age of the person | | | Methods | ---------- | | info(additional=&quot;&quot;): | Prints the person's name and age | | Methods defined here: | | __init__(self, name, age) | Constructs all the neccessary attributes for the person object | | Parameters | ---------- | name : str | name of the person | | age : int | age of the person | | info(self, additional=None) | 귀찮음... | | | Parameters | ---------- | additional : str, optional | more info to be displayed (Default is None) / A, B, C | | | Returns | ------- | None | | ---------------------------------------------------------------------- | Data descriptors defined here: | | __dict__ | dictionary for instance variables (if defined) | | __weakref__ | list of weak references to the object (if defined)","link":"/2022/03/23/basic_grammer_3/"},{"title":"Numpy 기초 문법","text":"NumPy 기초 문법NumPy 라이브 블러오기12import numpy as np # 앨리어싱print(np.__version__) 1.21.5 배열로 변환 1부터 10까지의 리스트를 만든다. NumPy 배열로 변환해서 저장한다. 123temp = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]arr = np.array(temp) # 리스트를 배열로 변환하자print(arr) [ 1 2 3 4 5 6 7 8 9 10] 타입 확인하기 12print(type(temp))print(type(arr)) # ndarray는 Numpy의 핵심인 다차원 행렬 자료구조 클래스 입니다. &lt;class 'list'&gt; &lt;class 'numpy.ndarray'&gt; arr 배열 숫자 5 출력 12print(arr[4]) # 인덱싱print(arr[4:8]) # 슬라이싱 5 [5 6 7 8] NumPy를 사용하여 기초 통계 함수를 사용한다. 1234print(np.mean(arr)) # 평균print(np.sum(arr)) # 합계print(np.median(arr)) # 중간값print(np.std(arr)) # 표준편차 5.5 55 5.5 2.8722813232690143 사칙연산12345math_scores = [90, 80, 88]english_scores = [80, 70, 90]total_scores = math_scores + english_scoresprint(total_scores) # 원하는 답이 안 나온다. [90, 80, 88, 80, 70, 90] 12345678math_scores = [90, 80, 88]english_scores = [80, 70, 90]math_arr = np.array(math_scores)english_arr = np.array(english_scores)total_scores = math_arr + english_arrprint(total_scores) # 원하는 답! [170 150 178] 12print(np.min(total_scores)) # 최솟값print(np.max(total_scores)) # 최댓값 150 178 NumPy 메서드사칙연산1234567891011121314# 덧셈print(&quot;덧셈:&quot;, np.add(math_arr, english_arr))# 뺄셈print(&quot;뺄셈:&quot;, np.subtract(math_arr, english_arr))# 곱셈print(&quot;곱셈:&quot;, np.multiply(math_arr, english_arr))# 나눗셈print(&quot;나눗셈:&quot;, np.divide(math_arr, english_arr))# 거듭제곱print(&quot;거듭제곱:&quot;, np.power(math_arr, english_arr)) # 값이 너무 크다. 그래서 0이 나옴 덧셈: [170 150 178] 뺄셈: [10 10 -2] 곱셈: [7200 5600 7920] 나눗셈: [1.125 1.14285714 0.97777778] 거듭제곱: [0 0 0] 배열의 생성 0차원부터 3차원까지 생성하는 방법 .shape 은 배열의 크기 .ndim 은 차원을 알려준다. 12345temp_arr = np.array(20)print(temp_arr)print(type(temp_arr))print(temp_arr.shape) # 배열의 크기print(temp_arr.ndim) # 차원은 0. 20 &lt;class 'numpy.ndarray'&gt; () 0 123456# 1차원 배열temp_arr = np.array([1, 2, 3])print(temp_arr)print(type(temp_arr))print(temp_arr.shape) # 1차원 배열에 3개의 사이즈print(temp_arr.ndim) # 차원이 1이다. [1 2 3] &lt;class 'numpy.ndarray'&gt; (3,) 1 2차원 배열12345temp_arr = np.array([[1, 2, 3],[4, 5, 6]])print(temp_arr)print(type(temp_arr))print(temp_arr.shape) # 2 * 3 배열print(temp_arr.ndim) # 차원이 2이다. [[1 2 3] [4 5 6]] &lt;class 'numpy.ndarray'&gt; (2, 3) 2 3차원 배열12345temp_arr = np.array([[[1, 2, 3],[4, 5, 6]], [[1, 2, 3],[4, 5, 6]]])print(temp_arr)print(type(temp_arr))print(temp_arr.shape) # 2 * 2 * 3 배열print(temp_arr.ndim) # 차원이 3이다. [[[1 2 3] [4 5 6]] [[1 2 3] [4 5 6]]] &lt;class 'numpy.ndarray'&gt; (2, 2, 3) 3 2 * 2 * 3 에서 각 숫자를 하나의 축이라고 생각하면 된다. 숫자가 3개니 3차원인 것이다. 12345temp_arr = np.array([1, 2, 3, 4], ndmin = 2)print(temp_arr)print(type(temp_arr))print(temp_arr.shape) # 1 * 4 배열print(temp_arr.ndim) # 차원이 2이다. [[1 2 3 4]] &lt;class 'numpy.ndarray'&gt; (1, 4) 2 마찬가지로, 1 * 4 는 2개의 축으로 이루어져 있으니 2차원인 것이다. 소숫점 정렬12temp_arr = np.trunc([-1.23, 1,23])temp_arr array([-1., 1., 23.]) 12temp_arr = np.fix([-1.23, 1,23])temp_arr array([-1., 1., 23.]) 12temp_arr = np.around([-1.23789, 1,23789], 4)temp_arr array([-1.2379e+00, 1.0000e+00, 2.3789e+04]) 12temp_arr = np.round([-1.23, 1,23], 4)temp_arr array([-1.23, 1. , 23. ]) 12temp_arr = np.floor([-1.23, 1,23])temp_arr array([-2., 1., 23.]) 12temp_arr = np.ceil([-1.23, 1,23])temp_arr array([-1., 1., 23.]) 다양한 배열 생성 방법12temp_arr = np.arange(5) # rangetemp_arr array([0, 1, 2, 3, 4]) 12temp_arr = np.arange(1, 9, 3) # 1에서부터 9까지 3칸씩 띄어라temp_arr array([1, 4, 7]) np.zeros(()) 는 원하는 사이즈만큼 0으로 구성된 배열 생성 123456zero_arr = np.zeros((2, 3)) # 원하는 사이즈만큼 0으로 구성된 배열 만들기print(zero_arr)print(type(zero_arr))print(zero_arr.shape)print(zero_arr.ndim)print(zero_arr.dtype) # float64는 비트 [[0. 0. 0.] [0. 0. 0.]] &lt;class 'numpy.ndarray'&gt; (2, 3) 2 float64 flaot64, 이게 지금은 중요하지 않지만, 나중에 프로젝트를 할 때, 필요한 내용이다. 예를 들면, int32와 float64는 연산이 안된다. https://numpy.org/doc/stable/user/basics.types.html np.ones(())는 원하는 사이즈만큼 1로 구성된 배열 생성 12345678temp_arr = np.ones((4, 5), dtype=&quot;int32&quot;) # 원하는 사이즈만큼 1로 구성된 배열 만들기 # dtype으로 비트유형을 바꿔줄 수 있다.print(temp_arr)print(type(temp_arr))print(temp_arr.shape)print(temp_arr.ndim)print(temp_arr.dtype) [[1 1 1 1 1] [1 1 1 1 1] [1 1 1 1 1] [1 1 1 1 1]] &lt;class 'numpy.ndarray'&gt; (4, 5) 2 int32 reshape -1의 의미는 자동설정해준다는 것이다. 나중에 머신러닝할 때 유용하다. magic keyword라고 한다. 123456789temp_arr = np.ones((12, 12), dtype=&quot;int32&quot;) temp_res_arr = temp_arr.reshape(4, -1) # -1은 알아서 자동설정 해준다.print(temp_res_arr)print(type(temp_res_arr))print(temp_res_arr.shape)print(temp_res_arr.ndim)print(temp_res_arr.dtype) [[1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1] [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]] &lt;class 'numpy.ndarray'&gt; (4, 36) 2 int32 numpy 조건식np.where(조건식, 참, 거짓) 조건식이 하나일때 np.where()을 사용한다. 12temp_arr = np.arange(10)temp_arr array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1234# 5보다 작은 값은 원래값으로 반환# 5보다 큰 값은 원래 값 * 10np.where(temp_arr &lt; 5, temp_arr, temp_arr * 10) array([ 0, 1, 2, 3, 4, 50, 60, 70, 80, 90]) 퀴즈 0 ~ 100 까지의 배열 생성 후, 50보다 작은 값은 곱하기 10, 나머지는 그냥 원래 값 반환 123temp_arr = np.arange(101)temp_arrnp.where(temp_arr &lt; 50, temp_arr * 10, temp_arr) array([ 0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120, 130, 140, 150, 160, 170, 180, 190, 200, 210, 220, 230, 240, 250, 260, 270, 280, 290, 300, 310, 320, 330, 340, 350, 360, 370, 380, 390, 400, 410, 420, 430, 440, 450, 460, 470, 480, 490, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) np.select(condlist, choicelist, default = ) 사실 다중조건을 더 많이 사용한다. 이 때는 np.select를 사용한다. condlist는 조건식 리스트이다. choicelist는 조건식이 참일때 수행할 명령 리스트이다. condlist와 choicelist 요소들은 맞춰주어야 한다. default를 설정 안해주면 0인데, 아래에서 확인해보자. 12345temp_arr = np.arange(10)temp_arr# 5보다 큰 수는 곱하기 2, 2보다 작은 값은 더하기 100 array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 1234condlist = [temp_arr &gt; 5, temp_arr &lt; 2] # 이거라면,choicelist = [temp_arr * 2, temp_arr + 100] # 이렇게 해줘라print(np.select(condlist, choicelist)) # default를 지정 안해주면, 조건에 맞지 않는 값들이 모두 0이 된다.print(np.select(condlist, choicelist, default = temp_arr)) [100 101 0 0 0 0 12 14 16 18] [100 101 2 3 4 5 12 14 16 18] 교재 넘파이 부분 손코딩 실습 도미와 빙어를 분류하는 머신러닝 코드짜기 1234567891011fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]fish_data = [[l ,w] for l, w in zip(fish_length, fish_weight)]fish_target = [1]*35 + [0]*14 12from sklearn.neighbors import KNeighborsClassifierkn = KNeighborsClassifier() 1print(fish_data[4]) # fish_data의 다섯 번째 샘플 가져오기 [29.0, 430.0] 1print(fish_data[0:5]) # fish_data의 처음 다섯 개의 샘플 가져오기 [[25.4, 242.0], [26.3, 290.0], [26.5, 340.0], [29.0, 363.0], [29.0, 430.0]] 1234train_input = fish_data[:35] # 처음부터 34번째 인덱스까지는 훈련 세트train_target = fish_target[:35]test_input = fish_data[35:] # 35번 부터 나머지까지는 테스트 세트test_target = fish_target[35:] 12kn = kn.fit(train_input, train_target)kn.score(test_input, test_target) # 정확도가 0... 0.0 도미와 빙어가 골고루 섞여야 하는데 마지막 35번부터는 빙어만 있으니 제대로 학습을 못하게 된 것. 이것을 샘플링 편향 sampling bias 즉, 훈련 세트에 도미만 있기 때문에 테스트 세트가 무엇이든 도미로 판단하게 된다. 골고루 섞기 위해서 numpy 라이브러리가 필요하다. 1234import numpy as npinput_arr = np.array(fish_data)target_arr = np.array(fish_target)print(input_arr) # 49개의 행(샘플)과 2개의 열(특성) [[ 25.4 242. ] [ 26.3 290. ] [ 26.5 340. ] [ 29. 363. ] [ 29. 430. ] [ 29.7 450. ] [ 29.7 500. ] [ 30. 390. ] [ 30. 450. ] [ 30.7 500. ] [ 31. 475. ] [ 31. 500. ] [ 31.5 500. ] [ 32. 340. ] [ 32. 600. ] [ 32. 600. ] [ 33. 700. ] [ 33. 700. ] [ 33.5 610. ] [ 33.5 650. ] [ 34. 575. ] [ 34. 685. ] [ 34.5 620. ] [ 35. 680. ] [ 35. 700. ] [ 35. 725. ] [ 35. 720. ] [ 36. 714. ] [ 36. 850. ] [ 37. 1000. ] [ 38.5 920. ] [ 38.5 955. ] [ 39.5 925. ] [ 41. 975. ] [ 41. 950. ] [ 9.8 6.7] [ 10.5 7.5] [ 10.6 7. ] [ 11. 9.7] [ 11.2 9.8] [ 11.3 8.7] [ 11.8 10. ] [ 11.8 9.9] [ 12. 9.8] [ 12.2 12.2] [ 12.4 13.4] [ 13. 12.2] [ 14.3 19.7] [ 15. 19.9]] 1print(input_arr.shape) # shape 메서드로 배열 구성 확인. 49행 2열 (49, 2) 넘파이 배열로 준비는 마쳤다. 여기에서 랜덤으로 추출해보자. 아예 인덱스를 섞은 다음 input_arr와 target_arr에서 샘플을 선택하면 무작위로 훈련 세트를 나누는 셈이 될 것이다. 넘파이 arange() 함수를 사용해서 0부터 48까지 1씩 증가하는 인덱스를 만든다. 인덱스를 랜덤하게 섞는다. 넘파이에서 무작위 결과를 만드는 함수들은 실행할 때마다 다른 결과를 만들기 때문에 일정한 결과를 얻으려면 랜덤 시드(random seed)를 지정해줘야 한다. 123np.random.seed(42) # 일정한 결과를 얻기 위한 랜덤 시드(random seed)index = np.arange(49) # 0부터 48까지 1씩 증가하는 인덱스 생성np.random.shuffle(index) # 인덱스를 랜덤하게 섞기 잘 만들어졌는지 체크해보자 1print(index) [13 45 47 44 17 27 26 25 31 19 12 4 34 8 3 6 40 41 46 15 9 16 24 33 30 0 43 32 5 29 11 36 1 21 2 37 35 23 39 10 22 18 48 20 7 42 14 28 38] 랜덤하게 섞인 인덱스를 가지고 전체 데이터를 훈련 세트와 테스트 세트로 나누자. 넘파이에 배열 인덱싱(array indexing) 기능 이용 1print(input_arr[[1,3]]) # input_arr 에서 두 번째와 네 번째 샘플 선택하여 추출 [[ 26.3 290. ] [ 29. 363. ]] 랜덤하게 35개의 샘플을 훈련 세트로 만들기 12train_input = input_arr[index[:35]]train_target = target_arr[index[:35]] 만들어진 index의 첫 번째 값은 13임을 확인했다. 따라서, train_input의 첫 번째 원소는 input_arr의 열 네 번째 원소가 들어있을 것이다. 확인해보자. 1print(input_arr[13], train_input[0]) # 동일하다 [ 32. 340.] [ 32. 340.] 이번에는 나머지 14개를 테스트 세트로 만들자 12test_input = input_arr[index[35:]]test_target = target_arr[index[35:]] 데이터 세트들이 잘 섞였는 지 산점도 그래프로 확인 1234567import matplotlib.pyplot as pltplt.scatter(train_input[:,0], train_input[:,1]) # 파란색이 훈련 세트plt.scatter(test_input[:,0], test_input[:,1]) # 주황색이 테스트 세트plt.xlabel('length')plt.ylabel('weight')plt.show()","link":"/2022/03/24/numpy_01/"},{"title":"10분 완성 Pandas","text":"Pandas 10분 완성 필사원본: https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html 번역본: https://dataitgirls2.github.io/10minutes2pandas/ 123import pandas as pdimport numpy as npimport matplotlib.pyplot as plt Object Creation (객체 생성) Pandas는 값을 가지고 있는 리스트를 통해 Series를 만들고, 정수로 만들어진 인덱스를 기본값으로 불러올 것입니다. 12s = pd.Series([1,3,5,np.nan,6,8])s 0 1.0 1 3.0 2 5.0 3 NaN 4 6.0 5 8.0 dtype: float64 datetime 인덱스와 레이블이 있는 열을 가지고 있는 numpy 배열을 전달하여 데이터프레임을 만듭니다. 12dates = pd.date_range('20130101', periods=6)dates DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') 12df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 0.300728 -0.263258 0.231729 -0.586384 2013-01-02 -1.099834 -1.311782 1.250473 -0.149189 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 2013-01-04 -0.591139 1.840492 1.067977 1.738770 2013-01-05 -0.157689 -0.352707 -0.331992 0.634488 2013-01-06 -1.640009 -0.620559 -1.613156 -2.163666 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-967c470c-7432-4134-a124-707e64036844 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-967c470c-7432-4134-a124-707e64036844'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Series와 같은 것으로 변환될 수 있는 객체들의 dict로 구성된 데이터프레임을 만듭니다. 1234567df2 = pd.DataFrame({'A' : 1., 'B' : pd.Timestamp('20130102'), 'C' : pd.Series(1,index=list(range(4)),dtype='float32'), 'D' : np.array([3] * 4, dtype='int32'), 'E' : pd.Categorical([&quot;test&quot;, &quot;train&quot;,&quot;test&quot;, &quot;train&quot;]), 'F' : 'foo'})df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E F 0 1.0 2013-01-02 1.0 3 test foo 1 1.0 2013-01-02 1.0 3 train foo 2 1.0 2013-01-02 1.0 3 test foo 3 1.0 2013-01-02 1.0 3 train foo &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-7bdbfccf-d22c-4fa9-afaf-b6f9252e8bbf button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-7bdbfccf-d22c-4fa9-afaf-b6f9252e8bbf'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 데이터프레임 결과물의 열은 다양한 데이터 타입 (dtypes)으로 구성됩니다. 1df2.dtypes A float64 B datetime64[ns] C float32 D int32 E category F object dtype: object IPython을 이용하고 계시다면 (공용 속성을 포함한) 열 이름에 대한 Tap 자동완성 기능이 자동으로 활성화 됩니다. 다음은 완성될 속성에 대한 부분집합 (subset)입니다. 역자 주 : 아래 제시된 코드의 경우, IPython이 아닌 환경 (Google Colaboratory, Jupyter 등)에서는 사용이 불가능한 코드인 점에 주의하세요. 2. Viewing Data(데이터 확인하기)12print(df.tail(3)) # 끝에서 마지막 3줄을 불러옴print(df.tail()) # 끝에서 마지막 5줄 불러옴 A B C D 2013-01-04 -0.591139 1.840492 1.067977 1.738770 2013-01-05 -0.157689 -0.352707 -0.331992 0.634488 2013-01-06 -1.640009 -0.620559 -1.613156 -2.163666 A B C D 2013-01-02 -1.099834 -1.311782 1.250473 -0.149189 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 2013-01-04 -0.591139 1.840492 1.067977 1.738770 2013-01-05 -0.157689 -0.352707 -0.331992 0.634488 2013-01-06 -1.640009 -0.620559 -1.613156 -2.163666 1df.head() # 위에서 5줄 불러옴 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 0.300728 -0.263258 0.231729 -0.586384 2013-01-02 -1.099834 -1.311782 1.250473 -0.149189 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 2013-01-04 -0.591139 1.840492 1.067977 1.738770 2013-01-05 -0.157689 -0.352707 -0.331992 0.634488 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-c8c15f14-8937-456e-80ef-1223b8608eef button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-c8c15f14-8937-456e-80ef-1223b8608eef'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 인덱스 (index), 열 (column) 그리고 numpy 데이터에 대한 세부 정보를 봅니다. 1df.index DatetimeIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05', '2013-01-06'], dtype='datetime64[ns]', freq='D') 1df.columns Index(['A', 'B', 'C', 'D'], dtype='object') 1df.values array([[ 0.30072817, -0.26325765, 0.23172949, -0.58638441], [-1.09983384, -1.31178153, 1.25047287, -0.14918936], [-0.3486452 , -0.91313229, 0.08737214, -0.6438286 ], [-0.59113876, 1.84049219, 1.06797729, 1.73876959], [-0.15768942, -0.35270749, -0.33199219, 0.6344876 ], [-1.64000873, -0.62055935, -1.61315579, -2.16366558]]) describe()는 데이터의 대략적인 통계적 정보 요약을 보여줍니다. 1df.describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D count 6.000000 6.000000 6.000000 6.000000 mean -0.589431 -0.270158 0.115401 -0.194968 std 0.692963 1.102985 1.039055 1.316046 min -1.640009 -1.311782 -1.613156 -2.163666 25% -0.972660 -0.839989 -0.227151 -0.629468 50% -0.469892 -0.486633 0.159551 -0.367787 75% -0.205428 -0.285620 0.858915 0.438568 max 0.300728 1.840492 1.250473 1.738770 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-e0954699-6177-4380-af7a-a41cf118eb02 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-e0954699-6177-4380-af7a-a41cf118eb02'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 데이터를 전치합니다. 1df.T .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 2013-01-01 2013-01-02 2013-01-03 2013-01-04 2013-01-05 2013-01-06 A 0.300728 -1.099834 -0.348645 -0.591139 -0.157689 -1.640009 B -0.263258 -1.311782 -0.913132 1.840492 -0.352707 -0.620559 C 0.231729 1.250473 0.087372 1.067977 -0.331992 -1.613156 D -0.586384 -0.149189 -0.643829 1.738770 0.634488 -2.163666 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-0bfe1c42-a2e3-45ce-85a6-f9d827483b84 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-0bfe1c42-a2e3-45ce-85a6-f9d827483b84'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 축 별로 정렬합니다. 1df.sort_index(axis=1, ascending=False) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } D C B A 2013-01-01 -0.586384 0.231729 -0.263258 0.300728 2013-01-02 -0.149189 1.250473 -1.311782 -1.099834 2013-01-03 -0.643829 0.087372 -0.913132 -0.348645 2013-01-04 1.738770 1.067977 1.840492 -0.591139 2013-01-05 0.634488 -0.331992 -0.352707 -0.157689 2013-01-06 -2.163666 -1.613156 -0.620559 -1.640009 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-41da6cb4-f979-4360-b434-78445763e479 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-41da6cb4-f979-4360-b434-78445763e479'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 값 별로 정렬합니다. 1df.sort_values(by='B') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-02 -1.099834 -1.311782 1.250473 -0.149189 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 2013-01-06 -1.640009 -0.620559 -1.613156 -2.163666 2013-01-05 -0.157689 -0.352707 -0.331992 0.634488 2013-01-01 0.300728 -0.263258 0.231729 -0.586384 2013-01-04 -0.591139 1.840492 1.067977 1.738770 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f495a21b-27c0-479d-8666-b36c68c7377e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f495a21b-27c0-479d-8666-b36c68c7377e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 3. Selection(선택)Getting(데이터 얻기) df.A 와 동일한 Series를 생성하는 단일 열을 선택합니다. 1df['A'] 2013-01-01 0.300728 2013-01-02 -1.099834 2013-01-03 -0.348645 2013-01-04 -0.591139 2013-01-05 -0.157689 2013-01-06 -1.640009 Freq: D, Name: A, dtype: float64 행을 분할하는 [ ]를 통해 선택합니다. 1df[0:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 0.300728 -0.263258 0.231729 -0.586384 2013-01-02 -1.099834 -1.311782 1.250473 -0.149189 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-5eddacfa-3ec5-4481-aab9-46338ea6faae button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-5eddacfa-3ec5-4481-aab9-46338ea6faae'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df['20130102':'20130104'] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-02 -1.099834 -1.311782 1.250473 -0.149189 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 2013-01-04 -0.591139 1.840492 1.067977 1.738770 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-66eab04d-22d8-4e5a-a15b-72a682ab923c button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-66eab04d-22d8-4e5a-a15b-72a682ab923c'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Selection by Label (label을 통한 선택)1df.loc[dates[0]] A 0.300728 B -0.263258 C 0.231729 D -0.586384 Name: 2013-01-01 00:00:00, dtype: float64 라벨을 사용하여 여러 축 (의 데이터)을 얻습니다. 1df.loc[:, ['A','B']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2013-01-01 0.300728 -0.263258 2013-01-02 -1.099834 -1.311782 2013-01-03 -0.348645 -0.913132 2013-01-04 -0.591139 1.840492 2013-01-05 -0.157689 -0.352707 2013-01-06 -1.640009 -0.620559 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-57d0309b-fbf8-4929-b398-0d60d67063ee button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-57d0309b-fbf8-4929-b398-0d60d67063ee'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 양쪽 종단점을 포함한 라벨 슬라이싱을 봅니다. 1df.loc['20130102':'20130104', ['A','B']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2013-01-02 -1.099834 -1.311782 2013-01-03 -0.348645 -0.913132 2013-01-04 -0.591139 1.840492 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-efba182b-23cd-4e19-bcb3-737481b2322b button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-efba182b-23cd-4e19-bcb3-737481b2322b'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 반환되는 객체의 차원를 줄입니다. 1df.loc['20130102',['A','B']] A -1.099834 B -1.311782 Name: 2013-01-02 00:00:00, dtype: float64 스칼라 값을 얻습니다. 1df.loc[dates[0],'A'] 0.30072817102461075 스칼라 값을 더 빠르게 구하는 방법입니다 (앞선 메소드와 동일합니다). 1df.at[dates[0], 'A'] 0.30072817102461075 Selection by Position(위치로 선택하기) 넘겨받은 정수의 위치를 기준으로 선택합니다. 1df.iloc[3] A -0.591139 B 1.840492 C 1.067977 D 1.738770 Name: 2013-01-04 00:00:00, dtype: float64 정수로 표기된 슬라이스들을 통해, numpy / python과 유사하게 작동합니다. 1df.iloc[3:5,0:2] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B 2013-01-04 -0.591139 1.840492 2013-01-05 -0.157689 -0.352707 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-c542aa0e-249b-4629-a46b-89bdb9af6fed button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-c542aa0e-249b-4629-a46b-89bdb9af6fed'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 정수로 표기된 위치값의 리스트들을 통해, numpy / python의 스타일과 유사해집니다. 1df.iloc[[1,2,4],[0,2]] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A C 2013-01-02 -1.099834 1.250473 2013-01-03 -0.348645 0.087372 2013-01-05 -0.157689 -0.331992 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-55d5daf9-c009-4d79-b075-b29d55365755 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-55d5daf9-c009-4d79-b075-b29d55365755'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 명시적으로 행을 나누고자 하는 경우입니다. 1df.iloc[1:3,:] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-02 -1.099834 -1.311782 1.250473 -0.149189 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-71b47cbb-5679-42a1-a3c2-9a4c0d93c913 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-71b47cbb-5679-42a1-a3c2-9a4c0d93c913'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 명시적으로 열을 나누고자 하는 경우입니다. 1df.iloc[:,1:3] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } B C 2013-01-01 -0.263258 0.231729 2013-01-02 -1.311782 1.250473 2013-01-03 -0.913132 0.087372 2013-01-04 1.840492 1.067977 2013-01-05 -0.352707 -0.331992 2013-01-06 -0.620559 -1.613156 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-9754adb0-b2e1-418c-b56a-aeac9f8649ee button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-9754adb0-b2e1-418c-b56a-aeac9f8649ee'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 명시적으로 (특정한) 값을 얻고자 하는 경우입니다. 1df.iloc[1,1] -1.311781527749884 스칼라 값을 빠르게 얻는 방법입니다 (위의 방식과 동일합니다). 1df.iat[1,1] -1.311781527749884 Boolean Indexing 데이터를 선택하기 위해 단일 열의 값을 사용합니다. 1df[df.A &gt; 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 0.300728 -0.263258 0.231729 -0.586384 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-16044eaf-c404-4801-9af5-c6041cce22c2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-16044eaf-c404-4801-9af5-c6041cce22c2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Boolean 조건을 충족하는 데이터프레임에서 값을 선택합니다. 1df[df &gt; 0] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2013-01-01 0.300728 NaN 0.231729 NaN 2013-01-02 NaN NaN 1.250473 NaN 2013-01-03 NaN NaN 0.087372 NaN 2013-01-04 NaN 1.840492 1.067977 1.738770 2013-01-05 NaN NaN NaN 0.634488 2013-01-06 NaN NaN NaN NaN &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-31e35218-2394-43e7-bc03-233c098097df button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-31e35218-2394-43e7-bc03-233c098097df'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 필터링을 위한 메소드 isin()을 사용합니다. 1df2 = df.copy() 12df2['E'] = ['one', 'one', 'two', 'three', 'four', 'three']df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2013-01-01 0.300728 -0.263258 0.231729 -0.586384 one 2013-01-02 -1.099834 -1.311782 1.250473 -0.149189 one 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 two 2013-01-04 -0.591139 1.840492 1.067977 1.738770 three 2013-01-05 -0.157689 -0.352707 -0.331992 0.634488 four 2013-01-06 -1.640009 -0.620559 -1.613156 -2.163666 three &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-332f267a-157c-4418-b60d-3d784156a52c button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-332f267a-157c-4418-b60d-3d784156a52c'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df2[df2['E'].isin(['two','four'])] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 2013-01-03 -0.348645 -0.913132 0.087372 -0.643829 two 2013-01-05 -0.157689 -0.352707 -0.331992 0.634488 four &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b0d3f1bc-76c3-42fa-80ac-b8f6838eae60 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b0d3f1bc-76c3-42fa-80ac-b8f6838eae60'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; setting(설정) 새 열을 설정하면 데이터가 인덱스 별로 자동 정렬됩니다. 12s1 = pd.Series([1,2,3,4,5,6], index=pd.date_range('20130102', periods=6))s1 2013-01-02 1 2013-01-03 2 2013-01-04 3 2013-01-05 4 2013-01-06 5 2013-01-07 6 Freq: D, dtype: int64 1df['F'] = s1 라벨에 의해 값을 설정합니다. 1df.at[dates[0],'A'] = 0 위치에 의해 값을 설정합니다. 1df.iat[0,1] = 0 Numpy 배열을 사용한 할당에 의해 값을 설정합니다. 12df.loc[:, 'D'] = np.array([5] * len(df))df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 0.231729 5 NaN 2013-01-02 -1.099834 -1.311782 1.250473 5 1.0 2013-01-03 -0.348645 -0.913132 0.087372 5 2.0 2013-01-04 -0.591139 1.840492 1.067977 5 3.0 2013-01-05 -0.157689 -0.352707 -0.331992 5 4.0 2013-01-06 -1.640009 -0.620559 -1.613156 5 5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-53de9a37-f969-4912-ac04-86a4cc6f332b button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-53de9a37-f969-4912-ac04-86a4cc6f332b'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; where 연산을 설정합니다. 1df2 = df.copy() 12df2[df2 &gt; 0] = -df2df2 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 -0.231729 -5 NaN 2013-01-02 -1.099834 -1.311782 -1.250473 -5 -1.0 2013-01-03 -0.348645 -0.913132 -0.087372 -5 -2.0 2013-01-04 -0.591139 -1.840492 -1.067977 -5 -3.0 2013-01-05 -0.157689 -0.352707 -0.331992 -5 -4.0 2013-01-06 -1.640009 -0.620559 -1.613156 -5 -5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-6b2a97e6-7a40-4d52-b4b0-11fa99013880 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-6b2a97e6-7a40-4d52-b4b0-11fa99013880'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Missing Data(결측치) Pandas는 결측치를 표현하기 위해 주로 np.nan 값을 사용합니다. Reindexing으로 지정된 축 상의 인덱스를 변경 / 추가 / 삭제할 수 있습니다. Reindexing은 데이터의 복사본을 반환합니다. 1df1 = df.reindex(index=dates[0:4], columns=list(df.columns) + ['E']) 12df1.loc[dates[0]:dates[1], 'E'] =1df1 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 0.000000 0.000000 0.231729 5 NaN 1.0 2013-01-02 -1.099834 -1.311782 1.250473 5 1.0 1.0 2013-01-03 -0.348645 -0.913132 0.087372 5 2.0 NaN 2013-01-04 -0.591139 1.840492 1.067977 5 3.0 NaN &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-854eff28-d5c6-493e-9c56-3d573cd836da button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-854eff28-d5c6-493e-9c56-3d573cd836da'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 결측치를 가지고 있는 행들을 지웁니다. 1df1.dropna(how='any') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-02 -1.099834 -1.311782 1.250473 5 1.0 1.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-9a8f93a0-529a-45d2-9bc3-6a5becc0ae58 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-9a8f93a0-529a-45d2-9bc3-6a5becc0ae58'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 결측치를 채워 넣습니다. 1df1.fillna(value=5) # 5로 채워넣기 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 0.000000 0.000000 0.231729 5 5.0 1.0 2013-01-02 -1.099834 -1.311782 1.250473 5 1.0 1.0 2013-01-03 -0.348645 -0.913132 0.087372 5 2.0 5.0 2013-01-04 -0.591139 1.840492 1.067977 5 3.0 5.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-15ea5efe-2279-441d-917a-153c8e4accb6 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-15ea5efe-2279-441d-917a-153c8e4accb6'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; nan인 값에 boolean을 통한 표식을 얻습니다. 역자 주 : 데이터프레임의 모든 값이 boolean 형태로 표시되도록 하며, nan인 값에만 True가 표시되게 하는 함수입니다. 1pd.isna(df1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F E 2013-01-01 False False False False True False 2013-01-02 False False False False False False 2013-01-03 False False False False False True 2013-01-04 False False False False False True &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-17e39b79-8d76-47c6-8375-a8f56909c185 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-17e39b79-8d76-47c6-8375-a8f56909c185'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Operation (연산)stats (통계) 일반적으로 결측치를 제외한 후 연산됩니다. 기술통계를 수행합니다. 1df.mean() A -0.639553 B -0.226281 C 0.115401 D 5.000000 F 3.000000 dtype: float64 다른 축에서 동일한 연산을 수행합니다. 1df.mean(1) 2013-01-01 1.307932 2013-01-02 0.967772 2013-01-03 1.165119 2013-01-04 2.063466 2013-01-05 1.631522 2013-01-06 1.225255 Freq: D, dtype: float64 정렬이 필요하며, 차원이 다른 객체로 연산해보겠습니다. 또한, pandas는 지정된 차원을 따라 자동으로 브로드 캐스팅됩니다. 역자 주 : broadcast란 numpy에서 유래한 용어로, n차원이나 스칼라 값으로 연산을 수행할 때 도출되는 결과의 규칙을 설명하는 것을 의미합니다. 12s = pd.Series([1,3,5,np.nan,6,8], index=dates).shift(2)s 2013-01-01 NaN 2013-01-02 NaN 2013-01-03 1.0 2013-01-04 3.0 2013-01-05 5.0 2013-01-06 NaN Freq: D, dtype: float64 1df.sub(s, axis='index') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 NaN NaN NaN NaN NaN 2013-01-02 NaN NaN NaN NaN NaN 2013-01-03 -1.348645 -1.913132 -0.912628 4.0 1.0 2013-01-04 -3.591139 -1.159508 -1.932023 2.0 0.0 2013-01-05 -5.157689 -5.352707 -5.331992 0.0 -1.0 2013-01-06 NaN NaN NaN NaN NaN &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-961448ec-241d-4b2b-bf3e-2b8c107e60b3 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-961448ec-241d-4b2b-bf3e-2b8c107e60b3'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Apply(적용) 데이터에 함수를 적용합니다. 1df.apply(np.cumsum) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D F 2013-01-01 0.000000 0.000000 0.231729 5 NaN 2013-01-02 -1.099834 -1.311782 1.482202 10 1.0 2013-01-03 -1.448479 -2.224914 1.569575 15 3.0 2013-01-04 -2.039618 -0.384422 2.637552 20 6.0 2013-01-05 -2.197307 -0.737129 2.305560 25 10.0 2013-01-06 -3.837316 -1.357688 0.692404 30 15.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-5fa85d8e-b443-4fcf-a35d-d5a22c845e81 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-5fa85d8e-b443-4fcf-a35d-d5a22c845e81'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.apply(lambda x: x.max() - x.min()) A 1.640009 B 3.152274 C 2.863629 D 0.000000 F 4.000000 dtype: float64 Hisrogrammin (히스토그래밍)12s = pd.Series(np.random.randint(0, 7, size=10))s 0 2 1 6 2 2 3 2 4 4 5 3 6 4 7 4 8 3 9 5 dtype: int64 1s.value_counts() 2 3 4 3 3 2 6 1 5 1 dtype: int64 string Methods(문자열 메소드) Series는 다음의 코드와 같이 문자열 처리 메소드 모음 (set)을 가지고 있습니다.이 모음은 배열의 각 요소를 쉽게 조작할 수 있도록 만들어주는 문자열의 속성에 포함되어 있습니다. 문자열의 패턴 일치 확인은 기본적으로 정규 표현식을 사용하며, 몇몇 경우에는 항상 정규 표현식을 사용함에 유의하십시오. 12s = pd.Series(['A', 'B', 'C', 'AaBa', 'Baca', np.nan, 'CABA', 'dog', 'cat'])s.str.lower() 0 a 1 b 2 c 3 aaba 4 baca 5 NaN 6 caba 7 dog 8 cat dtype: object Merge (병합)Concat (연결) 결합 (join) / 병합 (merge) 형태의 연산에 대한 인덱스, 관계 대수 기능을 위한 다양한 형태의 논리를 포함한 Series, 데이터프레임, Panel 객체를 손쉽게 결합할 수 있도록 하는 다양한 기능을 pandas 에서 제공합니다. 12df = pd.DataFrame(np.random.randn(10, 4))df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 1.178802 1.240268 0.060703 -2.452726 1 -0.916616 -0.699856 -2.644101 -0.649991 2 -0.379350 0.733153 1.738607 2.509139 3 0.767562 0.810325 1.201008 0.163146 4 0.605380 -1.187634 0.672423 0.936118 5 -0.440754 -0.039716 0.420964 0.054439 6 0.651187 -1.113766 0.354955 -0.271147 7 1.874887 -1.369062 -0.033655 -0.506732 8 0.921916 -0.950195 -0.304002 2.024843 9 0.038615 2.242273 -1.858805 -0.206487 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-6013bb9c-e791-4cbd-ae7f-70916e5330bc button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-6013bb9c-e791-4cbd-ae7f-70916e5330bc'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123# break it into piecespieces = [df[:3], df[3:7], df[7:]]pd.concat(pieces) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 0 1 2 3 0 1.178802 1.240268 0.060703 -2.452726 1 -0.916616 -0.699856 -2.644101 -0.649991 2 -0.379350 0.733153 1.738607 2.509139 3 0.767562 0.810325 1.201008 0.163146 4 0.605380 -1.187634 0.672423 0.936118 5 -0.440754 -0.039716 0.420964 0.054439 6 0.651187 -1.113766 0.354955 -0.271147 7 1.874887 -1.369062 -0.033655 -0.506732 8 0.921916 -0.950195 -0.304002 2.024843 9 0.038615 2.242273 -1.858805 -0.206487 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-0f103399-f83b-4a1a-a989-947d1f863afe button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-0f103399-f83b-4a1a-a989-947d1f863afe'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; join(결합) SQL 방식으로 병합합니다. 123left = pd.DataFrame({'key': ['foo', 'foo'], 'lval': [1, 2]})right = pd.DataFrame({'key': ['foo', 'foo'], 'rval': [4, 5]})left .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval 0 foo 1 1 foo 2 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-33c0a123-0496-477d-9dbf-77cb03dd8f02 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-33c0a123-0496-477d-9dbf-77cb03dd8f02'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1right .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key rval 0 foo 4 1 foo 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8d898d93-29c2-4b09-8537-80ba4b84dba6 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8d898d93-29c2-4b09-8537-80ba4b84dba6'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1pd.merge(left, right, on= 'key') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval rval 0 foo 1 4 1 foo 1 5 2 foo 2 4 3 foo 2 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-7417a0f2-233d-4ff9-9215-691582433e92 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-7417a0f2-233d-4ff9-9215-691582433e92'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 다른 예시입니다. 1234left = pd.DataFrame({'key' : ['foo', 'bar'], 'lval' : [1, 2]})right = pd.DataFrame({'key': ['foo', 'bar'], 'rval': [4, 5]})left .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval 0 foo 1 1 bar 2 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-83539243-821e-4da6-bba3-31cb6ede60da button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-83539243-821e-4da6-bba3-31cb6ede60da'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1right .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key rval 0 foo 4 1 bar 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-a227dc5d-7989-447c-9111-3ed378e30d1e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-a227dc5d-7989-447c-9111-3ed378e30d1e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1pd.merge(left, right, on= 'key') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } key lval rval 0 foo 1 4 1 bar 2 5 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-10bb1151-5184-40e9-a764-cc2a8c0e1d47 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-10bb1151-5184-40e9-a764-cc2a8c0e1d47'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Append (추가) 데이터프레임에 행을 추가합니다. 12df = pd.DataFrame(np.random.randn(8, 4), columns=['A', 'B', 'C', 'D'])df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 -0.707810 -0.616206 0.557429 -0.673691 1 0.398359 0.590156 0.024199 1.396677 2 -0.183290 0.047769 0.779775 1.442445 3 0.084316 -1.308026 -0.809909 -0.100735 4 -0.511133 -0.380242 -1.043381 -0.806634 5 -0.580510 -0.395366 0.717878 -0.685339 6 -1.166817 0.761797 -0.346222 1.487303 7 -1.198588 -0.761424 1.893708 1.162279 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-247e1446-ced9-4766-87ac-8f6a6c04247e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-247e1446-ced9-4766-87ac-8f6a6c04247e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12s = df.iloc[3]s A 0.084316 B -1.308026 C -0.809909 D -0.100735 Name: 3, dtype: float64 1df.append(s, ignore_index=True) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 -0.707810 -0.616206 0.557429 -0.673691 1 0.398359 0.590156 0.024199 1.396677 2 -0.183290 0.047769 0.779775 1.442445 3 0.084316 -1.308026 -0.809909 -0.100735 4 -0.511133 -0.380242 -1.043381 -0.806634 5 -0.580510 -0.395366 0.717878 -0.685339 6 -1.166817 0.761797 -0.346222 1.487303 7 -1.198588 -0.761424 1.893708 1.162279 8 0.084316 -1.308026 -0.809909 -0.100735 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-18f32566-d3d3-4b9d-bc46-7260ec1ca6ca button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-18f32566-d3d3-4b9d-bc46-7260ec1ca6ca'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Grouping (그룹화)-그룹화는 다음 단계 중 하나 이상을 포함하는 과정을 가리킵니다. 몇몇 기준에 따라 여러 그룹으로 데이터를 분할 (splitting) 각 그룹에 독립적으로 함수를 적용 (applying) 결과물들을 하나의 데이터 구조로 결합 (combining) 12345678df = pd.DataFrame( { 'A' : ['foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'foo'], 'B' : ['one', 'one', 'two', 'three', 'two', 'two', 'one', 'three'], 'C' : np.random.randn(8), 'D' : np.random.randn(8) })df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 foo one 1.069249 0.365181 1 bar one 0.137894 -0.394584 2 foo two -1.473601 0.771336 3 bar three -0.026117 0.153736 4 foo two 0.675027 0.977329 5 bar two -0.396978 -0.150105 6 foo one 1.017942 1.533993 7 foo three -1.410921 -0.479321 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b2b359ca-0618-47e5-b037-187352f6d190 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b2b359ca-0618-47e5-b037-187352f6d190'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 생성된 데이터프레임을 그룹화한 후 각 그룹에 sum() 함수를 적용합니다. 1df.groupby('A').sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C D A bar -0.285202 -0.390953 foo -0.122304 3.168518 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-d1705048-d15c-45e1-bfd0-a87c1641a436 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-d1705048-d15c-45e1-bfd0-a87c1641a436'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 여러 열을 기준으로 그룹화하면 계층적 인덱스가 형성됩니다. 여기에도 sum 함수를 적용할 수 있습니다. 1df.groupby(['A', 'B']).sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C D A B bar one 0.137894 -0.394584 three -0.026117 0.153736 two -0.396978 -0.150105 foo one 2.087191 1.899175 three -1.410921 -0.479321 two -0.798575 1.748664 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8697c255-46f3-4c53-bd92-5ce4e549ba97 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8697c255-46f3-4c53-bd92-5ce4e549ba97'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Reshaping(변형)Stack(스택)1234tuples = list(zip(*[['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], ['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two']])) 1234index = pd.MultiIndex.from_tuples(tuples, names=['first', 'second'])df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=['A', 'B'])df2 = df[:4]df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B first second bar one 0.046976 0.725962 two -0.368482 -0.562111 baz one 1.175016 -0.150060 two -0.494980 0.665989 foo one 1.328767 -0.932962 two 0.192983 1.109156 qux one -0.421099 -0.253088 two -0.872046 -1.090497 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-4c495b34-0698-4c12-b61e-df5d63669b09 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-4c495b34-0698-4c12-b61e-df5d63669b09'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; stack() 메소드는 데이터프레임 열들의 계층을 “압축”합니다. 12stacked = df2.stack()stacked first second bar one A 0.046976 B 0.725962 two A -0.368482 B -0.562111 baz one A 1.175016 B -0.150060 two A -0.494980 B 0.665989 dtype: float64 “Stack된” 데이터프레임 또는 (MultiIndex를 인덱스로 사용하는) Series인 경우, stack()의 역 연산은 unstack()이며, 기본적으로 마지막 계층을 unstack합니다. 1stacked.unstack() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B first second bar one 0.046976 0.725962 two -0.368482 -0.562111 baz one 1.175016 -0.150060 two -0.494980 0.665989 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-2a8b2ec1-992e-4699-8e27-b6263f7149bd button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-2a8b2ec1-992e-4699-8e27-b6263f7149bd'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1stacked.unstack(1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } second one two first bar A 0.046976 -0.368482 B 0.725962 -0.562111 baz A 1.175016 -0.494980 B -0.150060 0.665989 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-5f2284f0-d6dc-4fc6-8af0-f7212cf11085 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-5f2284f0-d6dc-4fc6-8af0-f7212cf11085'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1stacked.unstack(0) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } first bar baz second one A 0.046976 1.175016 B 0.725962 -0.150060 two A -0.368482 -0.494980 B -0.562111 0.665989 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-bbf1c47c-401a-4319-935f-677ccff31631 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-bbf1c47c-401a-4319-935f-677ccff31631'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Pivot Tables(피벗 테이블)123456df = pd.DataFrame({'A' : ['one', 'one', 'two', 'three'] * 3, 'B' : ['A', 'B', 'C'] * 4, 'C' : ['foo', 'foo', 'foo', 'bar', 'bar', 'bar'] * 2, 'D' : np.random.randn(12), 'E' : np.random.randn(12)})df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D E 0 one A foo 0.561255 0.791926 1 one B foo -0.401628 -0.185673 2 two C foo 0.184004 1.424850 3 three A bar 1.448154 1.572973 4 one B bar 0.213895 -1.251325 5 one C bar 0.135554 -0.691501 6 two A foo -0.329284 -1.046691 7 three B foo 0.921972 0.967578 8 one C foo 0.215366 -0.041228 9 one A bar 0.161393 -1.637091 10 two B bar 0.561090 1.233453 11 three C bar -0.513841 -1.183525 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-fe9d9c6b-c4d1-4e2d-9e73-d3c4dc01a1b4 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-fe9d9c6b-c4d1-4e2d-9e73-d3c4dc01a1b4'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 이 데이터로부터 피봇 테이블을 매우 쉽게 생성할 수 있습니다. 1pd.pivot_table(df, values='D', index=['A', 'B'], columns=['C']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } C bar foo A B one A 0.161393 0.561255 B 0.213895 -0.401628 C 0.135554 0.215366 three A 1.448154 NaN B NaN 0.921972 C -0.513841 NaN two A NaN -0.329284 B 0.561090 NaN C NaN 0.184004 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-c3f2f893-1f74-45ed-8a1a-858cb444e62b button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-c3f2f893-1f74-45ed-8a1a-858cb444e62b'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Times Seires (시계열) Pandas는 자주 일어나는 변환 (예시 : 5분마다 일어나는 데이터에 대한 2차 데이터 변환) 사이에 수행하는 리샘플링 연산을 위한 간단하고, 강력하며, 효율적인 함수를 제공합니다. 이는 재무 (금융) 응용에서 매우 일반적이지만 이에 국한되지는 않습니다. 123rng = pd.date_range('1/1/2012', periods=100, freq='S')ts = pd.Series(np.random.randint(0, 500, len(rng)), index=rng)ts.resample('5Min').sum() 2012-01-01 26641 Freq: 5T, dtype: int64 시간대를 표현합니다. 123rng = pd.date_range('3/6/2012 00:00', periods=5, freq='D')ts = pd.Series(np.random.randn(len(rng)), rng)ts 2012-03-06 0.581358 2012-03-07 -0.835184 2012-03-08 -1.291719 2012-03-09 0.349362 2012-03-10 -1.415495 Freq: D, dtype: float64 12ts_utc = ts.tz_localize('UTC')ts_utc 2012-03-06 00:00:00+00:00 0.581358 2012-03-07 00:00:00+00:00 -0.835184 2012-03-08 00:00:00+00:00 -1.291719 2012-03-09 00:00:00+00:00 0.349362 2012-03-10 00:00:00+00:00 -1.415495 Freq: D, dtype: float64 다른 시간대로 변환합니다. 1ts_utc.tz_convert('US/Eastern') 2012-03-05 19:00:00-05:00 0.581358 2012-03-06 19:00:00-05:00 -0.835184 2012-03-07 19:00:00-05:00 -1.291719 2012-03-08 19:00:00-05:00 0.349362 2012-03-09 19:00:00-05:00 -1.415495 Freq: D, dtype: float64 시간 표현 ↔ 기간 표현으로 변환합니다. 123rng = pd.date_range('1/1/2012', periods=5, freq='M')ts = pd.Series(np.random.randn(len(rng)), index=rng)ts 2012-01-31 0.748775 2012-02-29 0.516551 2012-03-31 -0.413149 2012-04-30 1.247230 2012-05-31 -1.076339 Freq: M, dtype: float64 12ps = ts.to_period()ps 2012-01 0.748775 2012-02 0.516551 2012-03 -0.413149 2012-04 1.247230 2012-05 -1.076339 Freq: M, dtype: float64 1ps.to_timestamp() 2012-01-01 0.748775 2012-02-01 0.516551 2012-03-01 -0.413149 2012-04-01 1.247230 2012-05-01 -1.076339 Freq: MS, dtype: float64 기간 ↔ 시간 변환은 편리한 산술 기능들을 사용할 수 있도록 만들어줍니다. 다음 예제에서, 우리는 11월에 끝나는 연말 결산의 분기별 빈도를 분기말 익월의 월말일 오전 9시로 변환합니다. 1234prng = pd.period_range('1990Q1', '2000Q4', freq='Q-NOV')ts = pd.Series(np.random.randn(len(prng)), prng)ts.index = (prng.asfreq('M', 'e') + 1).asfreq('H', 's') + 9ts.head() 1990-03-01 09:00 -1.061704 1990-06-01 09:00 -0.079417 1990-09-01 09:00 -0.444862 1990-12-01 09:00 -1.855021 1991-03-01 09:00 1.837690 Freq: H, dtype: float64 Categoricals(범주화) Pandas는 데이터프레임 내에 범주형 데이터를 포함할 수 있습니다. 12df = pd.DataFrame({&quot;id&quot;:[1,2,3,4,5,6], &quot;raw_grade&quot;:['a','b','b','a','a','e']})df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id raw_grade 0 1 a 1 2 b 2 3 b 3 4 a 4 5 a 5 6 e &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-e40d400c-1163-4773-a477-140c59e9c2e1 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-e40d400c-1163-4773-a477-140c59e9c2e1'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 가공하지 않은 성적을 범주형 데이터로 변환합니다. 12df[&quot;grade&quot;] = df[&quot;raw_grade&quot;].astype(&quot;category&quot;)df[&quot;grade&quot;] 0 a 1 b 2 b 3 a 4 a 5 e Name: grade, dtype: category Categories (3, object): ['a', 'b', 'e'] 범주에 더 의미 있는 이름을 붙여주세요 (Series.cat.categories로 할당하는 것이 적합합니다). 12df[&quot;grade&quot;].cat.categories = [&quot;very good&quot;, &quot;good&quot;, &quot;very bad&quot;] 범주의 순서를 바꾸고 동시에 누락된 범주를 추가합니다 (Series.cat에 속하는 메소드는 기본적으로 새로운 Series를 반환합니다). 12df[&quot;grade&quot;] = df[&quot;grade&quot;].cat.set_categories([&quot;very bad&quot;, &quot;bad&quot;, &quot;medium&quot;, &quot;good&quot;, &quot;very good&quot;])df[&quot;grade&quot;] 0 very good 1 good 2 good 3 very good 4 very good 5 very bad Name: grade, dtype: category Categories (5, object): ['very bad', 'bad', 'medium', 'good', 'very good'] 정렬은 사전 순서가 아닌, 해당 범주에서 지정된 순서대로 배열합니다. 역자 주 : 131번에서 very bad, bad, medium, good, very good 의 순서로 기재되어 있기 때문에 정렬 결과도 해당 순서대로 배열됩니다. 1df.sort_values(by=&quot;grade&quot;) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } id raw_grade grade 5 6 e very bad 1 2 b good 2 3 b good 0 1 a very good 3 4 a very good 4 5 a very good &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-1c2a0237-5699-4997-989a-33392ab7c550 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-1c2a0237-5699-4997-989a-33392ab7c550'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.groupby(&quot;grade&quot;).size() grade very bad 1 bad 0 medium 0 good 2 very good 3 dtype: int64 Plotting (그래프)123ts = pd.Series(np.random.randn(1000), index=pd.date_range('1/1/2000', periods=1000))ts = ts.cumsum()ts.plot() &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f89ebda41d0&gt; /images/10minutes_to_pandas 데이터프레임에서 plot() 메소드는 라벨이 존재하는 모든 열을 그릴 때 편리합니다. 1234df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, columns=['A', 'B', 'C', 'D'])df = df.cumsum()plt.figure(); df.plot(); plt.legend(loc='best') &lt;matplotlib.legend.Legend at 0x7f89eb792990&gt; &lt;Figure size 432x288 with 0 Axes&gt; Getting Data In / Out (데이터 입출력)CSV csv파일을 씁니다. 1df.to_csv('foo.csv') csv 파일을 읽습니다. 1pd.read_csv('foo.csv') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 A B C D 0 2000-01-01 0.077785 1.354574 0.335250 -0.643291 1 2000-01-02 1.506306 0.603573 1.431830 -0.151375 2 2000-01-03 2.046989 -0.243843 1.469860 -1.276268 3 2000-01-04 4.195420 -0.137163 0.435910 -1.063562 4 2000-01-05 5.022651 -0.684153 -0.179983 0.833490 ... ... ... ... ... ... 995 2002-09-22 60.234084 -33.177527 -12.221695 -38.068835 996 2002-09-23 60.599992 -32.577022 -13.140842 -38.394246 997 2002-09-24 60.739624 -30.809578 -13.287040 -38.570248 998 2002-09-25 60.622057 -31.091125 -13.027110 -39.217957 999 2002-09-26 62.868526 -31.140053 -12.690182 -39.383923 1000 rows × 5 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-09d8c0d4-bf7c-472f-813c-05a5e4ad76fe button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-09d8c0d4-bf7c-472f-813c-05a5e4ad76fe'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; HDF5 HDFStores에 읽고 씁니다. HDF5 Store에 씁니다. 1df.to_hdf('foo.h5', 'df') HDF5 Store에서 읽어옵니다. 1pd.read_hdf('foo.h5', 'df') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2000-01-01 0.077785 1.354574 0.335250 -0.643291 2000-01-02 1.506306 0.603573 1.431830 -0.151375 2000-01-03 2.046989 -0.243843 1.469860 -1.276268 2000-01-04 4.195420 -0.137163 0.435910 -1.063562 2000-01-05 5.022651 -0.684153 -0.179983 0.833490 ... ... ... ... ... 2002-09-22 60.234084 -33.177527 -12.221695 -38.068835 2002-09-23 60.599992 -32.577022 -13.140842 -38.394246 2002-09-24 60.739624 -30.809578 -13.287040 -38.570248 2002-09-25 60.622057 -31.091125 -13.027110 -39.217957 2002-09-26 62.868526 -31.140053 -12.690182 -39.383923 1000 rows × 4 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-88b181fb-5386-46b5-93ff-12fa70dae0a4 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-88b181fb-5386-46b5-93ff-12fa70dae0a4'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Excel MS Excel에 읽고 씁니다. 엑셀 파일에 씁니다. 1df.to_excel('foo.xlsx', sheet_name='Sheet1') 엑셀 파일을 읽어옵니다 1pd.read_excel('foo.xlsx', 'Sheet1', index_col=None, na_values=['NA']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unnamed: 0 A B C D 0 2000-01-01 0.077785 1.354574 0.335250 -0.643291 1 2000-01-02 1.506306 0.603573 1.431830 -0.151375 2 2000-01-03 2.046989 -0.243843 1.469860 -1.276268 3 2000-01-04 4.195420 -0.137163 0.435910 -1.063562 4 2000-01-05 5.022651 -0.684153 -0.179983 0.833490 ... ... ... ... ... ... 995 2002-09-22 60.234084 -33.177527 -12.221695 -38.068835 996 2002-09-23 60.599992 -32.577022 -13.140842 -38.394246 997 2002-09-24 60.739624 -30.809578 -13.287040 -38.570248 998 2002-09-25 60.622057 -31.091125 -13.027110 -39.217957 999 2002-09-26 62.868526 -31.140053 -12.690182 -39.383923 1000 rows × 5 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-ceafdb00-9193-41c5-910f-15ff5b0d4b1b button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-ceafdb00-9193-41c5-910f-15ff5b0d4b1b'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Gotchas (잡았다!) 연산 수행시 다음과 같은 예외 상황을 볼 수 도 있습니다. 이러한 경우에는 any(), all(), empty 등을 사용해서 무엇을 원하는지를 선택 (반영)해주어야 합니다. 12if pd.Series([False, True, False])is not None: print(&quot;I was not None true&quot;) I was not None true","link":"/2022/03/25/10minutes_to_pandas/"},{"title":"Pandas 입문 1","text":"판다스라이브러리 불러오기12import pandas as pdprint(pd.__version__) 1.3.5 테스트데이터 프레임123456temp_dic = {&quot;col1&quot; : [1, 2, 3], &quot;col2&quot; : [3, 4, 5]} # 먼저 딕셔너리를 만든다. df = pd.DataFrame(temp_dic) # 판다스는 객체가 시리즈와 데이터프레임으로 나뉜다.print(type(df))print(df) &lt;class 'pandas.core.frame.DataFrame'&gt; col1 col2 0 1 3 1 2 4 2 3 5 시리즈1234temp_dic = {'a':1, 'b':2, 'c':3} # 인덱스는 숫자나 문자나 모두 가능하다.ser = pd.Series(temp_dic)print(ser)print(type(ser)) a 1 b 2 c 3 dtype: int64 &lt;class 'pandas.core.series.Series'&gt; 언뜻 보기에는 같아보인다. 그러나, 다른 클래스고, 메서드도 다르다. 조심해야 한다. 데이터 불러오기구글 드라이브 연동Lemonade2016.csv 파일 12from google.colab import drivedrive.mount('/content/drive') Mounted at /content/drive 123DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/data/Lemonade2016.csv'juice = pd.read_csv(DATA_PATH) # 객체를 대문자로 썼는데, 개발자들이 좋아하는 방법이다. 눈에 띄는 걸 좋아한다. juice .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 0 7/1/2016 Park 97 67 70 90.0 0.25 1 7/2/2016 Park 98 67 72 90.0 0.25 2 7/3/2016 Park 110 77 71 104.0 0.25 3 7/4/2016 Beach 134 99 76 98.0 0.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 5 7/6/2016 Beach 103 69 82 90.0 0.25 6 7/6/2016 Beach 103 69 82 90.0 0.25 7 7/7/2016 Beach 143 101 81 135.0 0.25 8 NaN Beach 123 86 82 113.0 0.25 9 7/9/2016 Beach 134 95 80 126.0 0.25 10 7/10/2016 Beach 140 98 82 131.0 0.25 11 7/11/2016 Beach 162 120 83 135.0 0.25 12 7/12/2016 Beach 130 95 84 99.0 0.25 13 7/13/2016 Beach 109 75 77 99.0 0.25 14 7/14/2016 Beach 122 85 78 113.0 0.25 15 7/15/2016 Beach 98 62 75 108.0 0.50 16 7/16/2016 Beach 81 50 74 90.0 0.50 17 7/17/2016 Beach 115 76 77 126.0 0.50 18 7/18/2016 Park 131 92 81 122.0 0.50 19 7/19/2016 Park 122 85 78 113.0 0.50 20 7/20/2016 Park 71 42 70 NaN 0.50 21 7/21/2016 Park 83 50 77 90.0 0.50 22 7/22/2016 Park 112 75 80 108.0 0.50 23 7/23/2016 Park 120 82 81 117.0 0.50 24 7/24/2016 Park 121 82 82 117.0 0.50 25 7/25/2016 Park 156 113 84 135.0 0.50 26 7/26/2016 Park 176 129 83 158.0 0.35 27 7/27/2016 Park 104 68 80 99.0 0.35 28 7/28/2016 Park 96 63 82 90.0 0.35 29 7/29/2016 Park 100 66 81 95.0 0.35 30 7/30/2016 Beach 88 57 82 81.0 0.35 31 7/31/2016 Beach 76 47 82 68.0 0.35 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-377049de-a05e-4731-8fe4-a3adc97f89dd button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-377049de-a05e-4731-8fe4-a3adc97f89dd'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 데이터를 불러왔다. 데이터프레임 메서드를 하나씩 해볼 것이다. 첫번째 파악해야 하는 것 데이터 구조 1juice.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 32 entries, 0 to 31 Data columns (total 7 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Date 31 non-null object 1 Location 32 non-null object 2 Lemon 32 non-null int64 3 Orange 32 non-null int64 4 Temperature 32 non-null int64 5 Leaflets 31 non-null float64 6 Price 32 non-null float64 dtypes: float64(2), int64(3), object(2) memory usage: 1.9+ KB 결측치(NaN)가 있다면 Non-Null Count의 수가 다르다. Date, Leaflets는 결측치가 하나씩 있기 때문에 다른 칼럼에 비해 수가 하나 모자르다. 31. .head() 함수는 상위값 .tail() 함수는 하위값 1juice.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 0 7/1/2016 Park 97 67 70 90.0 0.25 1 7/2/2016 Park 98 67 72 90.0 0.25 2 7/3/2016 Park 110 77 71 104.0 0.25 3 7/4/2016 Beach 134 99 76 98.0 0.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-85ef7723-5da0-4047-9470-852c38d80b3d button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-85ef7723-5da0-4047-9470-852c38d80b3d'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1juice.tail() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price 27 7/27/2016 Park 104 68 80 99.0 0.35 28 7/28/2016 Park 96 63 82 90.0 0.35 29 7/29/2016 Park 100 66 81 95.0 0.35 30 7/30/2016 Beach 88 57 82 81.0 0.35 31 7/31/2016 Beach 76 47 82 68.0 0.35 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-2d82ba80-103f-4ffb-86a3-eb0b3ce806a0 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-2d82ba80-103f-4ffb-86a3-eb0b3ce806a0'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; describe() 함수 기술통계량 확인해주는 함수 12juice.describe()# type(juice.describe()) -&gt; dataframe .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Lemon Orange Temperature Leaflets Price count 32.000000 32.000000 32.000000 31.000000 32.000000 mean 116.156250 80.000000 78.968750 108.548387 0.354687 std 25.823357 21.863211 4.067847 20.117718 0.113137 min 71.000000 42.000000 70.000000 68.000000 0.250000 25% 98.000000 66.750000 77.000000 90.000000 0.250000 50% 113.500000 76.500000 80.500000 108.000000 0.350000 75% 131.750000 95.000000 82.000000 124.000000 0.500000 max 176.000000 129.000000 84.000000 158.000000 0.500000 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-617326f6-852f-40cd-8bdb-9e8c2ac9098d button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-617326f6-852f-40cd-8bdb-9e8c2ac9098d'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Location 칼럼은 문자라서 describe함수가 적용되지 않는다. value_counts() 12print(juice['Location'].value_counts())print(type(juice['Location'].value_counts())) # 얘는 시리즈네? Beach 17 Park 15 Name: Location, dtype: int64 &lt;class 'pandas.core.series.Series'&gt; 데이터 다뤄보기 행과 열을 만져보자. 열 추가(칼럼 추가) 12juice['sold'] = 0 # 새로운 컬럼 추가print(juice.head(3)) Date Location Lemon Orange Temperature Leaflets Price sold 0 7/1/2016 Park 97 67 70 90.0 0.25 0 1 7/2/2016 Park 98 67 72 90.0 0.25 0 2 7/3/2016 Park 110 77 71 104.0 0.25 0 12juice['sold'] = juice['Lemon'] + juice['Orange']print(juice.head(3)) Date Location Lemon Orange Temperature Leaflets Price sold 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 퀴즈 매출액 = 가격 * 판매량 Revenue 12juice['Revenue'] = juice['Price'] * juice['sold']print(juice.head(3)) Date Location Lemon Orange Temperature Leaflets Price sold \\ 0 7/1/2016 Park 97 67 70 90.0 0.25 164 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 Revenue 0 41.00 1 41.25 2 46.75 행과 열 제거 drop(axis=0, 1) axis를 0으로 설정 시, 행(=index) 방향으로 drop() 실행 axis를 1로 설정 시, 열 방향으로 drop 수행함. 12juice_column_drop = juice.drop('sold', axis = 1) # 열 방향, 'sold'열 하나가 통째로 삭제print(juice_column_drop.head(3)) Date Location Lemon Orange Temperature Leaflets Price Revenue 0 7/1/2016 Park 97 67 70 90.0 0.25 41.00 1 7/2/2016 Park 98 67 72 90.0 0.25 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 46.75 12juice_row_drop = juice.drop(0, axis = 0) # 행 방향, 인덱스 0이 통째로 삭제 print(juice_row_drop.head(3)) Date Location Lemon Orange Temperature Leaflets Price sold \\ 1 7/2/2016 Park 98 67 72 90.0 0.25 165 2 7/3/2016 Park 110 77 71 104.0 0.25 187 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 Revenue 1 41.25 2 46.75 3 58.25 데이터 인덱싱1juice[0:5] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price sold Revenue 0 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 1 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 2 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-3ff8756e-ccea-4443-937c-96dd4ef951a2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-3ff8756e-ccea-4443-937c-96dd4ef951a2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; boolean 값을 활용한 데이터추출1juice['Location'] == &quot;Beach&quot; 0 False 1 False 2 False 3 True 4 True 5 True 6 True 7 True 8 True 9 True 10 True 11 True 12 True 13 True 14 True 15 True 16 True 17 True 18 False 19 False 20 False 21 False 22 False 23 False 24 False 25 False 26 False 27 False 28 False 29 False 30 True 31 True Name: Location, dtype: bool 123# Location이 Beach인 경우# juice['Location'].value_counts()juice[juice['Location'] == &quot;Beach&quot;] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price sold Revenue 3 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 4 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 5 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 6 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 7 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 8 NaN Beach 123 86 82 113.0 0.25 209 52.25 9 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 10 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 11 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 12 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 13 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 14 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 15 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 16 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 17 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 30 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 31 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-f434477b-a70d-4d15-a445-7a178f78849e button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-f434477b-a70d-4d15-a445-7a178f78849e'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; iloc vs loc 차이를 확인한다. 1juice.iloc[:, 0:2] # 전체 데이터를 가져와라 그리고 0번부터 1번(n-1) 칼럼을 가져와라 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park 3 7/4/2016 Beach 4 7/5/2016 Beach 5 7/6/2016 Beach 6 7/6/2016 Beach 7 7/7/2016 Beach 8 NaN Beach 9 7/9/2016 Beach 10 7/10/2016 Beach 11 7/11/2016 Beach 12 7/12/2016 Beach 13 7/13/2016 Beach 14 7/14/2016 Beach 15 7/15/2016 Beach 16 7/16/2016 Beach 17 7/17/2016 Beach 18 7/18/2016 Park 19 7/19/2016 Park 20 7/20/2016 Park 21 7/21/2016 Park 22 7/22/2016 Park 23 7/23/2016 Park 24 7/24/2016 Park 25 7/25/2016 Park 26 7/26/2016 Park 27 7/27/2016 Park 28 7/28/2016 Park 29 7/29/2016 Park 30 7/30/2016 Beach 31 7/31/2016 Beach &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-d28556da-097b-4c4b-90f3-3548273e5785 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-d28556da-097b-4c4b-90f3-3548273e5785'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123%%timejuice.iloc[0:3, 0:2] #인덱스 0~2번, 0~1번 칼럼 CPU times: user 735 µs, sys: 0 ns, total: 735 µs Wall time: 843 µs .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-3313e9ec-a014-4d12-9209-3fc4ffa27eab button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-3313e9ec-a014-4d12-9209-3fc4ffa27eab'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; loc 라벨 기반 1234%%timejuice.loc[0:2, ['Date', 'Location']] # 인덱스 라벨과 칼럼 라벨 # 인덱싱에서 n-1개념과 다르다.# juice.loc[인덱스라벨, [칼럼 라벨]] CPU times: user 2.58 ms, sys: 0 ns, total: 2.58 ms Wall time: 6.81 ms .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location 0 7/1/2016 Park 1 7/2/2016 Park 2 7/3/2016 Park &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-69c0c626-2e18-4cf9-b0b9-4afab44368fd button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-69c0c626-2e18-4cf9-b0b9-4afab44368fd'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; iloc가 속도가 빠른 것을 %%time으로 확인 할 수 있다. 컬럼명 별도 추출 loc만 할 수 있는 기능 1juice.loc[juice['Leaflets'] &gt;= 100, ['Date', 'Location']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location 2 7/3/2016 Park 4 7/5/2016 Beach 7 7/7/2016 Beach 8 NaN Beach 9 7/9/2016 Beach 10 7/10/2016 Beach 11 7/11/2016 Beach 14 7/14/2016 Beach 15 7/15/2016 Beach 17 7/17/2016 Beach 18 7/18/2016 Park 19 7/19/2016 Park 22 7/22/2016 Park 23 7/23/2016 Park 24 7/24/2016 Park 25 7/25/2016 Park 26 7/26/2016 Park &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-cce733ce-3a3e-407b-a638-9ea77dfa236f button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-cce733ce-3a3e-407b-a638-9ea77dfa236f'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; iloc는 위가 안 된다. 정렬 sort_values() 1juice.sort_values(by=['Revenue'], ascending = False).head() # 내림차순으로 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price sold Revenue 25 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 18 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 26 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 19 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 24 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-fdaed60a-bf98-46fe-a701-24e216acb756 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-fdaed60a-bf98-46fe-a701-24e216acb756'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1234juice2 = juice.sort_values(by=['Price', 'Temperature'], ascending = [False, True]).reset_index(drop=True)juice2# 가격과 온도에 따라서 정렬을 해주다보니 인덱스 번호가 뒤죽박죽이 되어버렸다. 인덱스번호를 리셋 해주고 새로운 데이터셋으로 만들어준 것이다.# 그리고 juice2라는 새로운 객체에 저장해준 것. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Location Lemon Orange Temperature Leaflets Price sold Revenue 0 7/20/2016 Park 71 42 70 NaN 0.50 113 56.50 1 7/16/2016 Beach 81 50 74 90.0 0.50 131 65.50 2 7/15/2016 Beach 98 62 75 108.0 0.50 160 80.00 3 7/17/2016 Beach 115 76 77 126.0 0.50 191 95.50 4 7/21/2016 Park 83 50 77 90.0 0.50 133 66.50 5 7/19/2016 Park 122 85 78 113.0 0.50 207 103.50 6 7/22/2016 Park 112 75 80 108.0 0.50 187 93.50 7 7/18/2016 Park 131 92 81 122.0 0.50 223 111.50 8 7/23/2016 Park 120 82 81 117.0 0.50 202 101.00 9 7/24/2016 Park 121 82 82 117.0 0.50 203 101.50 10 7/25/2016 Park 156 113 84 135.0 0.50 269 134.50 11 7/27/2016 Park 104 68 80 99.0 0.35 172 60.20 12 7/29/2016 Park 100 66 81 95.0 0.35 166 58.10 13 7/28/2016 Park 96 63 82 90.0 0.35 159 55.65 14 7/30/2016 Beach 88 57 82 81.0 0.35 145 50.75 15 7/31/2016 Beach 76 47 82 68.0 0.35 123 43.05 16 7/26/2016 Park 176 129 83 158.0 0.35 305 106.75 17 7/1/2016 Park 97 67 70 90.0 0.25 164 41.00 18 7/3/2016 Park 110 77 71 104.0 0.25 187 46.75 19 7/2/2016 Park 98 67 72 90.0 0.25 165 41.25 20 7/4/2016 Beach 134 99 76 98.0 0.25 233 58.25 21 7/13/2016 Beach 109 75 77 99.0 0.25 184 46.00 22 7/5/2016 Beach 159 118 78 135.0 0.25 277 69.25 23 7/14/2016 Beach 122 85 78 113.0 0.25 207 51.75 24 7/9/2016 Beach 134 95 80 126.0 0.25 229 57.25 25 7/7/2016 Beach 143 101 81 135.0 0.25 244 61.00 26 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 27 7/6/2016 Beach 103 69 82 90.0 0.25 172 43.00 28 NaN Beach 123 86 82 113.0 0.25 209 52.25 29 7/10/2016 Beach 140 98 82 131.0 0.25 238 59.50 30 7/11/2016 Beach 162 120 83 135.0 0.25 282 70.50 31 7/12/2016 Beach 130 95 84 99.0 0.25 225 56.25 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-374e41cd-177f-4906-a3ce-e839f106f7a7 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-374e41cd-177f-4906-a3ce-e839f106f7a7'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; Groupby() 피벗 테이블을 만드는 것과 똑같음 요약하려고 1juice.groupby(by = 'Location').count() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Date Lemon Orange Temperature Leaflets Price sold Revenue Location Beach 16 17 17 17 17 17 17 17 Park 15 15 15 15 14 15 15 15 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-9d46cfb2-4ae7-44c5-a9de-d88d60478500 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-9d46cfb2-4ae7-44c5-a9de-d88d60478500'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 12import numpy as npjuice.groupby(['Location'])[['Revenue', 'Lemon']].agg([max, min, sum, np.mean]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead tr th { text-align: left; } .dataframe thead tr:last-of-type th { text-align: right; } Revenue Lemon max min sum mean max min sum mean Location Beach 95.5 43.0 1002.8 58.988235 162 76 2020 118.823529 Park 134.5 41.0 1178.2 78.546667 176 71 1697 113.133333 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-d175d024-02cf-46a7-a0ef-d792b2802f03 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-d175d024-02cf-46a7-a0ef-d792b2802f03'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt;","link":"/2022/03/26/Pandas_tutorial_01/"},{"title":"Pandas 입문 2","text":"groupby 집중 연습라이브러리 불러오기 pandas 라이브러리 불러오고, supermarket_sales.csv 파일 불러오기 참고로 미얀마 자료. 얀곤이 옛 수도, 네피도는 현 수도 12import pandas as pdprint(pd.__version__) 1.3.5 12from google.colab import drivedrive.mount('/content/drive') # &quot;/content/drive&quot; 도 가능 Mounted at /content/drive 123DATA_PATH = '/content/drive/MyDrive/Colab Notebooks/data/supermarket_sales.csv'sales = pd.read_csv(DATA_PATH) # 객체를 대문자로 썼는데, 개발자들이 좋아하는 방법이다. 눈에 띄는 걸 좋아한다. sales .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Invoice ID Branch City Customer type Gender Product line Unit price Quantity Date Time Payment 0 750-67-8428 A Yangon Member Female Health and beauty 74.69 7 1/5/2019 13:08 Ewallet 1 226-31-3081 C Naypyitaw Normal Female Electronic accessories 15.28 5 3/8/2019 10:29 Cash 2 631-41-3108 A Yangon Normal Male Home and lifestyle 46.33 7 3/3/2019 13:23 Credit card 3 123-19-1176 A Yangon Member Male Health and beauty 58.22 8 1/27/2019 20:33 Ewallet 4 373-73-7910 A Yangon Normal Male Sports and travel 86.31 7 2/8/2019 10:37 Ewallet ... ... ... ... ... ... ... ... ... ... ... ... 995 233-67-5758 C Naypyitaw Normal Male Health and beauty 40.35 1 1/29/2019 13:46 Ewallet 996 303-96-2227 B Mandalay Normal Female Home and lifestyle 97.38 10 3/2/2019 17:16 Ewallet 997 727-02-1313 A Yangon Member Male Food and beverages 31.84 1 2/9/2019 13:22 Cash 998 347-56-2442 A Yangon Normal Male Home and lifestyle 65.82 1 2/22/2019 15:33 Cash 999 849-09-3807 A Yangon Member Female Fashion accessories 88.34 7 2/18/2019 13:28 Cash 1000 rows × 11 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-2c107087-f544-4f62-bedd-767a947c87b5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-2c107087-f544-4f62-bedd-767a947c87b5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 역시 인포부터 알아본다. 1sales.info() &lt;class 'pandas.core.frame.DataFrame'&gt; RangeIndex: 1000 entries, 0 to 999 Data columns (total 11 columns): # Column Non-Null Count Dtype --- ------ -------------- ----- 0 Invoice ID 1000 non-null object 1 Branch 1000 non-null object 2 City 1000 non-null object 3 Customer type 1000 non-null object 4 Gender 1000 non-null object 5 Product line 1000 non-null object 6 Unit price 1000 non-null float64 7 Quantity 1000 non-null int64 8 Date 1000 non-null object 9 Time 1000 non-null object 10 Payment 1000 non-null object dtypes: float64(1), int64(1), object(9) memory usage: 86.1+ KB Group by (동의어) 집계함수를 배운다. 123sales['Invoice ID'].value_counts()# 송장번호로 그룹화 하기는 어렵겠다...# 적절한 기준을 찾을 때까지 노가다 해야한다. 750-67-8428 1 642-61-4706 1 816-72-8853 1 491-38-3499 1 322-02-2271 1 .. 633-09-3463 1 374-17-3652 1 378-07-7001 1 433-75-6987 1 849-09-3807 1 Name: Invoice ID, Length: 1000, dtype: int64 12sales.groupby('Product line')['Quantity'].sum()# 어떤 칼럼으로 그룹을 지을지 고민해야한다. Product line Electronic accessories 971 Fashion accessories 902 Food and beverages 952 Health and beauty 854 Home and lifestyle 911 Sports and travel 920 Name: Quantity, dtype: int64 1sales.groupby(['Product line', 'Branch', 'Payment'])['Quantity'].sum() Product line Branch Payment Electronic accessories A Cash 85 Credit card 121 Ewallet 116 B Cash 134 Credit card 83 Ewallet 99 C Cash 179 Credit card 58 Ewallet 96 Fashion accessories A Cash 60 Credit card 85 Ewallet 118 B Cash 110 Credit card 100 Ewallet 87 C Cash 110 Credit card 108 Ewallet 124 Food and beverages A Cash 78 Credit card 114 Ewallet 121 B Cash 41 Credit card 138 Ewallet 91 C Cash 176 Credit card 83 Ewallet 110 Health and beauty A Cash 98 Credit card 73 Ewallet 86 B Cash 113 Credit card 97 Ewallet 110 C Cash 82 Credit card 104 Ewallet 91 Home and lifestyle A Cash 139 Credit card 85 Ewallet 147 B Cash 94 Credit card 93 Ewallet 108 C Cash 73 Credit card 81 Ewallet 91 Sports and travel A Cash 112 Credit card 102 Ewallet 119 B Cash 136 Credit card 88 Ewallet 98 C Cash 76 Credit card 109 Ewallet 80 Name: Quantity, dtype: int64 여기서 시리즈타입과 데이터프레임타입 구분이 중요하다. 위의 표는 무슨 타입일까? 1print(type(sales.groupby(['Product line', 'Branch', 'Payment'])['Quantity'].sum())) &lt;class 'pandas.core.series.Series'&gt; 이게 시리즈 타입이라고?? 시리즈는 인덱스 하나 + 칼럼 하나로 구성된 것이 아니었나… Product line, Branch, Payment 세 개가 함께 인덱스란 소리다. “Multi index” 가장 오른쪽에 나오는 숫자열이 한 개의 칼럼에 해당 시리즈 타입을 데이터프레임 타입으로 바꾸고 싶어 구글링 필요. as_index = False 1sales.groupby(['Product line', 'Branch', 'Payment'], as_index=False)['Quantity'].sum() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Product line Branch Payment Quantity 0 Electronic accessories A Cash 85 1 Electronic accessories A Credit card 121 2 Electronic accessories A Ewallet 116 3 Electronic accessories B Cash 134 4 Electronic accessories B Credit card 83 5 Electronic accessories B Ewallet 99 6 Electronic accessories C Cash 179 7 Electronic accessories C Credit card 58 8 Electronic accessories C Ewallet 96 9 Fashion accessories A Cash 60 10 Fashion accessories A Credit card 85 11 Fashion accessories A Ewallet 118 12 Fashion accessories B Cash 110 13 Fashion accessories B Credit card 100 14 Fashion accessories B Ewallet 87 15 Fashion accessories C Cash 110 16 Fashion accessories C Credit card 108 17 Fashion accessories C Ewallet 124 18 Food and beverages A Cash 78 19 Food and beverages A Credit card 114 20 Food and beverages A Ewallet 121 21 Food and beverages B Cash 41 22 Food and beverages B Credit card 138 23 Food and beverages B Ewallet 91 24 Food and beverages C Cash 176 25 Food and beverages C Credit card 83 26 Food and beverages C Ewallet 110 27 Health and beauty A Cash 98 28 Health and beauty A Credit card 73 29 Health and beauty A Ewallet 86 30 Health and beauty B Cash 113 31 Health and beauty B Credit card 97 32 Health and beauty B Ewallet 110 33 Health and beauty C Cash 82 34 Health and beauty C Credit card 104 35 Health and beauty C Ewallet 91 36 Home and lifestyle A Cash 139 37 Home and lifestyle A Credit card 85 38 Home and lifestyle A Ewallet 147 39 Home and lifestyle B Cash 94 40 Home and lifestyle B Credit card 93 41 Home and lifestyle B Ewallet 108 42 Home and lifestyle C Cash 73 43 Home and lifestyle C Credit card 81 44 Home and lifestyle C Ewallet 91 45 Sports and travel A Cash 112 46 Sports and travel A Credit card 102 47 Sports and travel A Ewallet 119 48 Sports and travel B Cash 136 49 Sports and travel B Credit card 88 50 Sports and travel B Ewallet 98 51 Sports and travel C Cash 76 52 Sports and travel C Credit card 109 53 Sports and travel C Ewallet 80 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8d1795bd-e055-460d-8f14-0c4e1c3f00d5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8d1795bd-e055-460d-8f14-0c4e1c3f00d5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1print(type(sales.groupby(['Product line', 'Branch', 'Payment'], as_index=False)['Quantity'].sum())) &lt;class 'pandas.core.frame.DataFrame'&gt; 결측치 다루기결측치 데이터 생성 임의로 만들기 대부분 딕셔너리 형태 12345678910import pandas as pdimport numpy as npdict_01 = { 'Score_A' : [80,90,np.nan,80], 'Score_B' : [30,45,np.nan, np.nan], 'Score_C' : [np.nan, 50,80,90] }df = pd.DataFrame(dict_01)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C 0 80.0 30.0 NaN 1 90.0 45.0 50.0 2 NaN NaN 80.0 3 80.0 NaN 90.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-cf88f083-c896-4734-b449-7286820b6a16 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-cf88f083-c896-4734-b449-7286820b6a16'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.isnull().sum() # 각 컬럼의 결측치 개수 Score_A 1 Score_B 2 Score_C 1 dtype: int64 True = 숫자 1로 인식 False = 숫자 0으로 인식 12type(df.isnull().sum()) # 중간중간 타입을 확인하는 이유는 시리즈와 데이터프레임 메서드가 다르니까 그런것이다.# 표 보다는 그래프로 보여주면 더 인식하기 쉽다. pandas.core.series.Series 12df.fillna(&quot;입력값&quot;) # &quot;입력값&quot;으로 채우기# df.fillna(&quot;0&quot;) -&gt; 0으로 채우기 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C 0 80.0 30.0 입력값 1 90.0 45.0 50.0 2 입력값 입력값 80.0 3 80.0 입력값 90.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-a445638e-d7a2-4313-8ad8-ec710da9a067 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-a445638e-d7a2-4313-8ad8-ec710da9a067'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.fillna(method=&quot;pad&quot;) # 결측치 바로 위에 있는 값으로 채우기 .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C 0 80.0 30.0 NaN 1 90.0 45.0 50.0 2 90.0 45.0 80.0 3 80.0 45.0 90.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8721f51c-2ef4-419b-8511-8e0a18fd252a button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8721f51c-2ef4-419b-8511-8e0a18fd252a'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123456dict_01 = { &quot;성별&quot; : [&quot;남자&quot;, &quot;여자&quot;, np.nan, &quot;남자&quot;], &quot;Salary&quot; : [30, 45, 90, 70]}df = pd.DataFrame(dict_01)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } 성별 Salary 0 남자 30 1 여자 45 2 NaN 90 3 남자 70 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-c9256c94-14de-4167-a50f-4ab030334a2d button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-c9256c94-14de-4167-a50f-4ab030334a2d'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df['성별'].fillna(&quot;성별 없음&quot;) # 성별 칼럼에서만 결측치 원하는 값으로 채우기 0 남자 1 여자 2 성별 없음 3 남자 Name: 성별, dtype: object 결측치 –&gt; 문자열 타입 / 숫자 타입 접근 방법이 다르다.–&gt; 문자열 (빈도 –&gt; 가장 많이 나타나는 문자열 넣어주기!, 최빈값)–&gt; 숫자열 (평균, 최대, 최소, 중간, 이상치로 처리, 기타 등등..) Score_D 결측치 없는 칼럼 추가1234567891011import pandas as pdimport numpy as npdict_01 = { 'Score_A' : [80,90,np.nan,80], 'Score_B' : [30,45,np.nan, 60], 'Score_C' : [np.nan, 50,80,90], 'Score_D' : [50, 30, 80, 60] }df = pd.DataFrame(dict_01)df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C Score_D 0 80.0 30.0 NaN 50 1 90.0 45.0 50.0 30 2 NaN NaN 80.0 80 3 80.0 60.0 90.0 60 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-e3909644-07fd-4398-9f80-787495b12866 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-e3909644-07fd-4398-9f80-787495b12866'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 인덱스1, 3(1행, 3행), D열은 결측치가 없다. 12df.dropna(axis = 1) # axis = 1 은 컬럼기준 # axis = 0 은 인덱스 기준# 결측치가 있는 컬럼은 없애주겠다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_D 0 50 1 30 2 80 3 60 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-4e41ca0e-e4ca-40cc-a91c-14b180a756bf button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-4e41ca0e-e4ca-40cc-a91c-14b180a756bf'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 1df.dropna(axis = 0) # 결측치가 있는 인덱스(행)은 없애주겠다. .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Score_A Score_B Score_C Score_D 1 90.0 45.0 50.0 30 3 80.0 60.0 90.0 60 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-7d8b6c36-b63e-46c9-a499-6fd349891ef2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-7d8b6c36-b63e-46c9-a499-6fd349891ef2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 이상치12sales .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Invoice ID Branch City Customer type Gender Product line Unit price Quantity Date Time Payment 0 750-67-8428 A Yangon Member Female Health and beauty 74.69 7 1/5/2019 13:08 Ewallet 1 226-31-3081 C Naypyitaw Normal Female Electronic accessories 15.28 5 3/8/2019 10:29 Cash 2 631-41-3108 A Yangon Normal Male Home and lifestyle 46.33 7 3/3/2019 13:23 Credit card 3 123-19-1176 A Yangon Member Male Health and beauty 58.22 8 1/27/2019 20:33 Ewallet 4 373-73-7910 A Yangon Normal Male Sports and travel 86.31 7 2/8/2019 10:37 Ewallet ... ... ... ... ... ... ... ... ... ... ... ... 995 233-67-5758 C Naypyitaw Normal Male Health and beauty 40.35 1 1/29/2019 13:46 Ewallet 996 303-96-2227 B Mandalay Normal Female Home and lifestyle 97.38 10 3/2/2019 17:16 Ewallet 997 727-02-1313 A Yangon Member Male Food and beverages 31.84 1 2/9/2019 13:22 Cash 998 347-56-2442 A Yangon Normal Male Home and lifestyle 65.82 1 2/22/2019 15:33 Cash 999 849-09-3807 A Yangon Member Female Fashion accessories 88.34 7 2/18/2019 13:28 Cash 1000 rows × 11 columns &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-eadd2087-3f9d-4047-a8f0-8d2fa7572222 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-eadd2087-3f9d-4047-a8f0-8d2fa7572222'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 일반적인 통계 공식은 IQR(Interquartile Range) - 박스플롯 - 사분위수 Q0(0), Q1(25%), Q2(50%), Q3(75%), Q4(100%) IQR = Q3 - Q1 이상치의 하한 경계값 : Q1 - (1.5 * (Q3-Q1)) 이상치의 상한 경계값 : Q3 + (1.5 * (Q3-Q1)) 도메인(각 비즈니스 영역, 미래 일자리)에서 바라보는 이상치 기준(관습) 더 중요한 것은 관습이다. 1sales[['Unit price']].describe() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Unit price count 1000.000000 mean 55.672130 std 26.494628 min 10.080000 25% 32.875000 50% 55.230000 75% 77.935000 max 99.960000 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-c275e09e-666c-4e82-b6f2-72bbe50e96e4 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-c275e09e-666c-4e82-b6f2-72bbe50e96e4'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 123456789Q1 = sales['Unit price'].quantile(0.25)Q3 = sales['Unit price'].quantile(0.75)outliers_Q1 = Q1 - 1.5 * (Q3-Q1)outliers_Q1 # -34.~~ 값은 쓰기 어렵다. 이럴 경우에는 임의로 정해준다.# 이상치의 하한값을 그냥 Q1으로 잡는다.real_outliers_Q1 = (sales['Unit price'] &lt; Q1)# 이상치의 상한값을 마찬가지로 Q3로 잡는다.real_outliers_Q3 = (sales['Unit price'] &gt; Q3) 1print(sales['Unit price'][~(real_outliers_Q1|real_outliers_Q3)]) 0 74.69 2 46.33 3 58.22 6 68.84 7 73.56 ... 991 76.60 992 58.03 994 60.95 995 40.35 998 65.82 Name: Unit price, Length: 500, dtype: float64","link":"/2022/03/27/pandas_tutorial_02/"},{"title":"혼자서 공부하는 머신러닝 + 딥러닝_ch1_3","text":"ch1_3 page 44-64 읽고 정리 첫 번째 임무 : 생선 이름을 자동으로 알려주는 머신러닝 만들기생선 분류 문제 생선 데이터셋 출처 : https://www.kaggle.com/aungpyaeap/fish-market 생선 길이가 30cm 이상이면 도미다. 12if fish_length &gt;= 30: print(&quot;도미&quot;) 머신러닝은 스스로 기준을 찾아서 일을 한다. 머신러닝은 기준을 찾을 뿐만 아니라 이 기준을 이용해 생선이 도미인지 아닌지 판별할 수도 있다.도미 데이터 준비하기 먼저, 도미와 빙어를 구분해보자. Bream VS Smelt 주의! 여러 개의 종류(클래스) 중 하나를 구별하는 문제를 분류라고 부른다. 2개의 클래스 중 하나를 고르는 문제를 이진 분류(binary classification)라고 한다. 여기서 클래스는 파이썬에서 클래스와는 다르다. 12345678910111213# http://bit.ly/bream_list# 도미의 길이 데이터bream_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0]# 도미의 무게 데이터bream_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0] --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-6-edf837b3e2f5&gt; in &lt;module&gt;() 12 13 bream_df = [bream_length, bream_weight] ---&gt; 14 bream_df.shape() AttributeError: 'list' object has no attribute 'shape' feature(특성)은 데이터의 특징이다. 첫 번째 도미의 특성은 길이가 25.4cm이고, 무게는 242.0g이다. 두 특성을 좀 더 명확히 이해하기 위해 산점도 그래프(scatter plot)로 표현해보자. 123456import matplotlib.pyplot as plt # matplotlib의 pyplot 함수를 plt로 앨리어싱plt.scatter(bream_length, bream_weight)plt.xlabel('length') # x축은 길이plt.ylabel('weight') # y축은 무게plt.show() 빙어 데이터 준비하기123456# http://bit.ly/smelt_list# 빙어의 길이smelt_length = [9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]# 빙어의 무게smelt_weight = [6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9] 산점도 그래프 12345plt.scatter(bream_length, bream_weight)plt.scatter(smelt_length, smelt_weight)plt.xlabel('length') # x축은 길이plt.ylabel('weight') # y축은 무게plt.show() 첫 번째 머신러닝 프로그램K-최근접 이웃 알고리즘(K-Nearest Neighbors) 도미와 빙어 데이터 합치기 파이썬에서는 두 리스트를 더하면 하나의 리스트가 된다. 1234length = bream_length + smelt_lengthweight = bream_weight + smelt_weightprint(length)print(weight) [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0] [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9] 사이킷런 머신러닝 패키지를 사용하기 위해 세로 방향 2차원 리스트로 만들기 zip() 함수와 리스트 내포 구문(list comprehension) 12fish_data = [[l, w] for l, w in zip(length, weight)]print(fish_data) [[25.4, 242.0], [26.3, 290.0], [26.5, 340.0], [29.0, 363.0], [29.0, 430.0], [29.7, 450.0], [29.7, 500.0], [30.0, 390.0], [30.0, 450.0], [30.7, 500.0], [31.0, 475.0], [31.0, 500.0], [31.5, 500.0], [32.0, 340.0], [32.0, 600.0], [32.0, 600.0], [33.0, 700.0], [33.0, 700.0], [33.5, 610.0], [33.5, 650.0], [34.0, 575.0], [34.0, 685.0], [34.5, 620.0], [35.0, 680.0], [35.0, 700.0], [35.0, 725.0], [35.0, 720.0], [36.0, 714.0], [36.0, 850.0], [37.0, 1000.0], [38.5, 920.0], [38.5, 955.0], [39.5, 925.0], [41.0, 975.0], [41.0, 950.0], [9.8, 6.7], [10.5, 7.5], [10.6, 7.0], [11.0, 9.7], [11.2, 9.8], [11.3, 8.7], [11.8, 10.0], [11.8, 9.9], [12.0, 9.8], [12.2, 12.2], [12.4, 13.4], [13.0, 12.2], [14.3, 19.7], [15.0, 19.9]] zip() 함수 출처 : https://www.daleseo.com/python-zip/ 마치 점퍼의 zipper 처럼 두 그룹의 데이터를 서로 엮어주는 파이썬의 내장 함수 12345# 예제numbers = [1, 2, 3]letters = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]for pair in zip(numbers, letters): print(pair) # zip()함수는 튜플 형태로 반환한다. (1, 'A') (2, 'B') (3, 'C') 123456# zip() 함수를 사용하지 않고, index 변수를 사용하는 방법numbers = [1, 2, 3]letters = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]for i in range(3): pair = (numbers[i], letters[i]) print(pair) (1, 'A') (2, 'B') (3, 'C') 2차원 리스트 혹은 리스트의 리스트 fish_data처럼, 각각의 데이터가 리스트이며, 그 데이터들이 모여 있는 리스트를 2차원 리스트 혹은 리스트의 리스트라 한다. 정답 데이터 만들기 머신러닝은 구분하는 규칙 찾기를 원한다. 그렇게 하려면 정답을 알려줘야 한다. 도미는 1, 빙어는 0으로 만들어준다. 관습적으로 원하는 답을 1로, 그 외는 0으로 놓는다. 123# 정답 데이터fish_target = [1] * 35 + [0] * 14print(fish_target) [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] KNeighborsClassifier 임포트 파이썬에서 패키지나 모듈 전체를 임포트하지 않고 특정 클래스만 임포트 하려면 from ~ import 구문을 사용한다. 1234from sklearn.neighbors import KNeighborsClassifier# 객체 만들기kn = KNeighborsClassifier() training (훈련) 이 객체에 fish_data와 fish_target을 전달하여 도미를 찾기 위한 기준을 학습시킨다. 사이킷런에서는 fit()메서드가 훈련을 시킨다. 1kn.fit(fish_data, fish_target) KNeighborsClassifier() 평가 객체(또는 모델) kn이 얼마나 잘 훈련되었는지 평가해보자. 사이킷런에서 모델을 평가하는 메서드는 score()이다. 1kn.score(fish_data, fish_target) 1.0 정확도(accuracy) 정확도가 1.0 이 모델의 정확도가 100% 도미와 빙어를 완벽하게 분류했다. K-최근접 이웃 알고리즘 어떤 데이터에 대한 답을 구할 떄 주위의 다른 데이터를 보고 다수를 차지하는 것을 정답으로 사용한다. predict() 메서드는 새로운 데이터의 정답을 예측한다. fit() 메서드와 마찬가지로 2차원 리스트를 전달해야 한다. 12# predict() 메서드kn.predict([[30, 600]]) array([1]) 30cm에 600g인 생선은 도미로 예측했다. 사이킷런의 KNeighborsClassifier 클래스1print(kn._fit_X) [[ 25.4 242. ] [ 26.3 290. ] [ 26.5 340. ] [ 29. 363. ] [ 29. 430. ] [ 29.7 450. ] [ 29.7 500. ] [ 30. 390. ] [ 30. 450. ] [ 30.7 500. ] [ 31. 475. ] [ 31. 500. ] [ 31.5 500. ] [ 32. 340. ] [ 32. 600. ] [ 32. 600. ] [ 33. 700. ] [ 33. 700. ] [ 33.5 610. ] [ 33.5 650. ] [ 34. 575. ] [ 34. 685. ] [ 34.5 620. ] [ 35. 680. ] [ 35. 700. ] [ 35. 725. ] [ 35. 720. ] [ 36. 714. ] [ 36. 850. ] [ 37. 1000. ] [ 38.5 920. ] [ 38.5 955. ] [ 39.5 925. ] [ 41. 975. ] [ 41. 950. ] [ 9.8 6.7] [ 10.5 7.5] [ 10.6 7. ] [ 11. 9.7] [ 11.2 9.8] [ 11.3 8.7] [ 11.8 10. ] [ 11.8 9.9] [ 12. 9.8] [ 12.2 12.2] [ 12.4 13.4] [ 13. 12.2] [ 14.3 19.7] [ 15. 19.9]] 1print(kn._y) [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0] 실제로 k-최근접 이웃 알고리즘은 무언가 훈련되는 게 없는 셈이다. fit() 메서드에 전달한 데이터를 모두 저장하고 있다가 새로운 데이터가 등장하면 가장 가까운 데이터를 참고하여 도미인지 빙어인지를 구분한다. 123# 참고 데이터를 49개로 한 kn49모델# 기본값은 5kn49 = KNeighborsClassifier(n_neighbors=49) 49개를 참고 데이터로 하면, 그 중에 도미가 35개로 다수를 차지하므로 어떤 데이터를 넣어도 무조건 도미로 예측하게 된다. 12345# 어떤 데이터를 넣어도 무조건 도미라고 말하는 알고리즘kn49.fit(fish_data, fish_target)print(kn49.score(fish_data, fish_target))print(35/49) 0.7142857142857143 0.7142857142857143","link":"/2022/03/28/ch1_3/"},{"title":"혼자서 공부하는 머신러닝 + 딥러닝 ch2_1","text":"훈련 세트와 테스트 세트 지도 학습과 비지도 학습 지도 학습은 정답(타깃)이 있으니 알고리즘이 정답을 맞히는 것을 학습한다. 비지도 학습은 정답을 사용하지 않으므로 무언가를 맞힐 순 없지만, 데이터를 잘 파악하거나 변형하는 데 도움을 준다. 강화학습도 있다. 부록에 적어둔 책 참조. 핸즈온 머신러닝 2판(한빛미디어, 2020) 머신 러닝 교과서 with 파이썬, 사이킷런, 텐서플로 개정 3판(길벗, 2021) 훈련 세트와 테스트 세트 머신러닝의 성능을 제대로 평가하려면 훈련 데이터와 평가에 사용할 데이터가 각각 달라야 한다. 일반적으로 준비된 데이터 중에 일부는 테스트 세트로 활용하고 나머지는 훈련 세트로 활용한다. 12345678fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9] 두 리스트를 하나의 리스트로 담은 2차원 리스트를 만든다. 12fish_data = [[l, w] for l, w in zip(fish_length, fish_weight)]fish_target = [1]*35 + [0]*14 KNeighborsClassifier 클래스 모델 객체 만들기 12from sklearn.neighbors import KNeighborsClassifierkn = KNeighborsClassifier() 전체 데이터에서 처음 35개를 선택 슬라이싱 1234567891011# 훈련 세트로 입력값 중 0부터 34번째 인덱스까지 사용train_input = fish_data[:35]# 훈련 세트로 타깃값 중 0부터 34번째 인덱스까지 사용train_target = fish_target[:35]# 테스트 세트로 입력값 중 35번째 부터 마지막 인덱스까지test_input = fish_data[35:]# 테스트 세트로 타깃값 중 35번째부터 마지막 까지test_target = fish_target[35:] 모델 훈련1kn = kn.fit(train_input, train_target) 평가1kn.score(test_input, test_target) 0.0 샘플링 편향(sampleing bias) 정확도가 0은 뭔가 문제가 있다는 소리. 마지막 14개를 테스트 세트로 놓으면 훈련 세트에는 빙어가 하나도 들어있지 않은 문제 발생. 골고루 섞어야 한다. 넘파이(numpy) 샘플링 편향을 막기위해 샘플을 골고루 섞어주는 라이브러리 파이썬의 대표적인 배열(array) 라이브러리 데이터를 2차원 넘파이 배열로 변환 1import numpy as np 123input_arr = np.array(fish_data)target_arr = np.array(fish_target)print(input_arr) [[ 25.4 242. ] [ 26.3 290. ] [ 26.5 340. ] [ 29. 363. ] [ 29. 430. ] [ 29.7 450. ] [ 29.7 500. ] [ 30. 390. ] [ 30. 450. ] [ 30.7 500. ] [ 31. 475. ] [ 31. 500. ] [ 31.5 500. ] [ 32. 340. ] [ 32. 600. ] [ 32. 600. ] [ 33. 700. ] [ 33. 700. ] [ 33.5 610. ] [ 33.5 650. ] [ 34. 575. ] [ 34. 685. ] [ 34.5 620. ] [ 35. 680. ] [ 35. 700. ] [ 35. 725. ] [ 35. 720. ] [ 36. 714. ] [ 36. 850. ] [ 37. 1000. ] [ 38.5 920. ] [ 38.5 955. ] [ 39.5 925. ] [ 41. 975. ] [ 41. 950. ] [ 9.8 6.7] [ 10.5 7.5] [ 10.6 7. ] [ 11. 9.7] [ 11.2 9.8] [ 11.3 8.7] [ 11.8 10. ] [ 11.8 9.9] [ 12. 9.8] [ 12.2 12.2] [ 12.4 13.4] [ 13. 12.2] [ 14.3 19.7] [ 15. 19.9]] 넘파이 배열 객체는 배열의 크기를 알려주는 shape 속성을 제공한다. 1print(input_arr.shape) # (샘플 수, 특성 수) (49, 2) 49개의 행(샘플) 2개의 열(특성) 골고루 섞어주기 배열을 섞은 후에 나누는 방식 대신, 무작위로 샘플을 고르는 방법을 사용한다. 주의할 점은 input_arr와 target_arr에서 같은 위치는 함께 선택되어야 한다는 점이다. 그러려면, 훈련 세트와 테스트 세트로 나눌 인덱스값을 기억해야 한다. 넘파이 arange() 함수를 사용하면 0 ~ 48까지 1씩 증가하는 인덱스를 만들 수 있다. 그다음 이 인덱스를 골고루 섞어준다. 1234np.random.seed(42) # 골고루 섞어줬지만, 항상 일정한 결과를 얻기 위해index = np.arange(49)np.random.shuffle(index)print(index) [13 45 47 44 17 27 26 25 31 19 12 4 34 8 3 6 40 41 46 15 9 16 24 33 30 0 43 32 5 29 11 36 1 21 2 37 35 23 39 10 22 18 48 20 7 42 14 28 38] 골고루 섞인 인덱스를 이용해 훈련 세트와 테스트 세트로 나누자. 배열 인덱싱(array indexing) 여러 개의 인덱스로 한 번에 여러 개의 원소를 선택할 수 있다. 예를 들면, 12print(input_arr[[1, 3]]) [[ 26.3 290. ] [ 29. 363. ]] 비슷한 방식으로 리스트 대신 넘파이 배열을 인덱스로 전달할 수 있다. 12train_input = input_arr[index[:35]]train_target = target_arr[index[:35]] 만들어진 index의 첫 번째 값은 13이다. 따라서 train_input의 첫 번째 원소는 input_arr의 열네 번째 원소가 들어 있을 것이다. 1print(input_arr[13], train_input[0]) # 둘이 일치함을 확인 [ 32. 340.] [ 32. 340.] 마찬가지로, 테스트 세트를 만들자. 12test_input = input_arr[index[35:]]test_target = target_arr[index[35:]] 시각화123456789from matplotlib import pyplot as pltfig, ax = plt.subplots()ax.scatter(train_input[:, 0], train_input[:, 1])ax.scatter(test_input[:, 0], test_input[:, 1])ax.set_xlabel('length')ax.set_ylabel('weight')plt.show() 2차원 배열은 행과 열 인덱스를 콤마(,)로 나누어 지정한다. 슬라이싱 연산자로 처음부터 마지막 원소까지 모두 선택하는 경우 시작과 종료 인덱스를 모두 생략할 수 있다. train_input[:, 0]의 의미는 행은 처음부터 마지막 원소, 열은 0열을 가져오라는 것이다. 1train_input array([[ 32. , 340. ], [ 12.4, 13.4], [ 14.3, 19.7], [ 12.2, 12.2], [ 33. , 700. ], [ 36. , 714. ], [ 35. , 720. ], [ 35. , 725. ], [ 38.5, 955. ], [ 33.5, 650. ], [ 31.5, 500. ], [ 29. , 430. ], [ 41. , 950. ], [ 30. , 450. ], [ 29. , 363. ], [ 29.7, 500. ], [ 11.3, 8.7], [ 11.8, 10. ], [ 13. , 12.2], [ 32. , 600. ], [ 30.7, 500. ], [ 33. , 700. ], [ 35. , 700. ], [ 41. , 975. ], [ 38.5, 920. ], [ 25.4, 242. ], [ 12. , 9.8], [ 39.5, 925. ], [ 29.7, 450. ], [ 37. , 1000. ], [ 31. , 500. ], [ 10.5, 7.5], [ 26.3, 290. ], [ 34. , 685. ], [ 26.5, 340. ]]) 다시 돌아오면, 파란색이 훈련 세트이고, 주황색이 테스트 세트이다. 골고루 섞여 있음을 확인했다. 두 번째 머신러닝 프로그램 KNeighborsClassifier 클래스 12# 모델 훈련kn = kn.fit(train_input, train_target) 12#평가kn.score(test_input, test_target) 1.0 12# 예측kn.predict(test_input) array([0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0]) 1test_target array([0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0]) predict() 메서드의 출력 결과가 test_target의 출력과 동일하게 array()로 감싸 있는 것을 확인한다. predict() 메서드가 반환하는 값은 넘파이 배열이다. 사실 사이킷런 모델의 입력과 출력은 모두 넘파이 배열이다.","link":"/2022/03/29/ch_2_1/"},{"title":"혼자서 공부하는 머신러닝 + 딥러닝 ch3_1","text":"k-최근접 이웃 회귀 1234567891011121314151617181920import numpy as np# 농어의 데이터 (perch)perch_length = np.array( [8.4, 13.7, 15.0, 16.2, 17.4, 18.0, 18.7, 19.0, 19.6, 20.0, 21.0, 21.0, 21.0, 21.3, 22.0, 22.0, 22.0, 22.0, 22.0, 22.5, 22.5, 22.7, 23.0, 23.5, 24.0, 24.0, 24.6, 25.0, 25.6, 26.5, 27.3, 27.5, 27.5, 27.5, 28.0, 28.7, 30.0, 32.8, 34.5, 35.0, 36.5, 36.0, 37.0, 37.0, 39.0, 39.0, 39.0, 40.0, 40.0, 40.0, 40.0, 42.0, 43.0, 43.0, 43.5, 44.0] )perch_weight = np.array( [5.9, 32.0, 40.0, 51.5, 70.0, 100.0, 78.0, 80.0, 85.0, 85.0, 110.0, 115.0, 125.0, 130.0, 120.0, 120.0, 130.0, 135.0, 110.0, 130.0, 150.0, 145.0, 150.0, 170.0, 225.0, 145.0, 188.0, 180.0, 197.0, 218.0, 300.0, 260.0, 265.0, 250.0, 250.0, 300.0, 320.0, 514.0, 556.0, 840.0, 685.0, 700.0, 700.0, 690.0, 900.0, 650.0, 820.0, 850.0, 900.0, 1015.0, 820.0, 1100.0, 1000.0, 1100.0, 1000.0, 1000.0] ) K-최근접이웃 회귀(Regression) 중요도 : 하 ( 그냥 넘아가) 1967년에 만들어짐. 굉장히 옛날 모델. 알고리즘은 예측정확성이 가장 중요한데, 최근접이웃은 가장 낮게 나옴. 따라서, 현업에서 쓸 일이 없다. 시각화12345# 시각화의 안좋은 예(교재)import matplotlib.pyplot as pltplt.scatter(perch_length, perch_weight)plt.show() 12345678# 시각화의 좋은 예(객체 지향)fig, ax = plt.subplots()ax.scatter(perch_length, perch_weight)# xlabel, ylabel은 구글링을 찾아라ax.set_xlabel(&quot;length&quot;)ax.set_ylabel(&quot;weight&quot;)plt.show() 앞으로 시각화는 객체 지향으로 분석 30을 기준으로 자르면 30 이전은 완만하고, 30 이상은 급격하다. 30 이전은 편차가 작고, 30 이상은 편차가 크다. 훈련데이터와 테스트데이터셋으로 분리 가급적 코드 외우기 123456from sklearn.model_selection import train_test_splittrain_input, test_input, train_target, test_target = train_test_split( perch_length, perch_weight, random_state=42)# random_state = 42 는 랜덤시드 고정을 자동으로 해준다# ndim을 찍으면 모두 1차원배열로 나온다.print(train_input.shape, test_input.shape) (42,) (14,) 12test_array = np.array([1,2,3,4])print(test_array.shape) (4,) 12test_array = test_array.reshape(2, 2)print(test_array.shape) (2, 2) reshape() 사용하여 2차원 배열 바꿈 머신러닝은 2차원 배열로 넣어야 한다. 12345train_input = train_input.reshape(-1, 1) # -1은 매직test_input = test_input.reshape(-1, 1)print(train_input.shape, test_input.shape) (42, 1) (14, 1) 결정계수 모델이 얼마만큼 정확하냐? 절댓값은 아님/ 상대적인 값 123456789101112from sklearn.neighbors import KNeighborsRegressor# knn 클래스 불러오기knr = KNeighborsRegressor()# 모형학습knr.fit(train_input, train_target)# 테스트 점수 확인하자. -&gt; 얼마나 정확하냐? -&gt; 실무에서는 잘 나와야 70%knr.score(test_input, test_target) 0.992809406101064 오차가 작으면 작을수록 좋은 모델. 100%을 예측하는 것은 있을 수 없다. MAE 타깃과 예측의 절댓값 오차를 평균하여 반환 mean_absolute_error는 타깃과 예측의 절댓값 오차를 평균하여 반환한다. 12345from sklearn.metrics import mean_absolute_error# 예측 데이터 만들기test_prediction = knr.predict(test_input)test_prediction array([ 60. , 79.6, 248. , 122. , 136. , 847. , 311.4, 183.4, 847. , 113. , 1010. , 60. , 248. , 248. ]) mae를 구한다. 12mae = mean_absolute_error(test_target, test_prediction)print(mae) 19.157142857142862 이게 무슨 뜻이냐면, 평균적으로 19g정도 다르다. 분산 구할때는 제곱을 해준것이고, 지금은 절댓값을 씌운것이다. 절대적인 게 아니라 상대적인 것이다. 과대적합 vs 과소적합 공통점은 머신러닝 모형이 실제 테스트 시 잘 예측을 못한다는 것. 과대적합 : 훈련데이터에는 예측 잘함 / 테스트 데이터에서는 예측을 잘못함. 처리하기 곤란 비일비재 하다 과소적합 : 훈련데이터에서는 예측 못함 / 테스트데이터에서는 예측을 잘함. or 둘다 예측을 잘못함. 보통 과소적합은 신경 안써도 된다. 데이터 양이 적거나, 모델을 너무 간단하게 만들어서 비롯된 문제이기 때문. 12# 훈련 데이터 점수 확인하자.knr.score(train_input, train_target) 0.9698823289099254 0.97 정도 나옴 상사왈: 0.98로 올려봐 k-최근접 기본값이 5인데, 3으로 줄여봄 123456789# Default = 5를 3으로 변경# 머신러닝 모형을 살짝 변경# 옷으로 비유하면, 꽉끼는 옷에 단추가 5개였는데, 2개를 풀었다는 소리knr.n_neighbors = 3# 모데을 다시 훈련knr.fit(train_input, train_target)print(knr.score(train_input, train_target)) 0.9804899950518966 훈련데이터로 검증했더니 0.98 1print(knr.score(test_input, test_target)) 0.9746459963987609 MAE 구하기 123test_prediction = knr.predict(test_input)mae = mean_absolute_error(test_target, test_prediction)print(mae) 35.42380952380951 뭔가 이상하다.. 오차 값이 19 -&gt; 35 결론 k 그룹을 5로 했을 때, R2(결정계수) 점수는 0.98, MAE는 19였음. k 그룹을 3으로 했을 때, R2 점수는 0.97, MAE는 35였음. k 그룹 = n으로 반복될 것이다. 사용자 정의 함수를 사용한다. 최적의 k를 찾는 것이 머신러닝!!! 5장에서 배울 것.","link":"/2022/03/30/ch_3_1/"},{"title":"이중 for문","text":"쉬운 예제 : 구구단표for문으로 2단 만들기 출처 : [ Python 기초 ] 반복문1 (for문, 이중 for문) https://velog.io/@hj5730/Python-%EA%B8%B0%EC%B4%88-%EB%B0%98%EB%B3%B5%EB%AC%B81-for%EB%AC%B8-%EC%9D%B4%EC%A4%91-for%EB%AC%B8 12345a = 2for b in range(1, 10): c = a * b print('%d X %d = %d' % (a, b, c)) 2 X 1 = 2 2 X 2 = 4 2 X 3 = 6 2 X 4 = 8 2 X 5 = 10 2 X 6 = 12 2 X 7 = 14 2 X 8 = 16 2 X 9 = 18 이중 for문으로 전체 구구단표 만들기12345678print('-' * 50)for a in range(2, 10): for b in range(1, 10): c = a * b print('%d x %d = %d' % (a, b, c)) print('-' * 50) -------------------------------------------------- 2 x 1 = 2 2 x 2 = 4 2 x 3 = 6 2 x 4 = 8 2 x 5 = 10 2 x 6 = 12 2 x 7 = 14 2 x 8 = 16 2 x 9 = 18 -------------------------------------------------- 3 x 1 = 3 3 x 2 = 6 3 x 3 = 9 3 x 4 = 12 3 x 5 = 15 3 x 6 = 18 3 x 7 = 21 3 x 8 = 24 3 x 9 = 27 -------------------------------------------------- 4 x 1 = 4 4 x 2 = 8 4 x 3 = 12 4 x 4 = 16 4 x 5 = 20 4 x 6 = 24 4 x 7 = 28 4 x 8 = 32 4 x 9 = 36 -------------------------------------------------- 5 x 1 = 5 5 x 2 = 10 5 x 3 = 15 5 x 4 = 20 5 x 5 = 25 5 x 6 = 30 5 x 7 = 35 5 x 8 = 40 5 x 9 = 45 -------------------------------------------------- 6 x 1 = 6 6 x 2 = 12 6 x 3 = 18 6 x 4 = 24 6 x 5 = 30 6 x 6 = 36 6 x 7 = 42 6 x 8 = 48 6 x 9 = 54 -------------------------------------------------- 7 x 1 = 7 7 x 2 = 14 7 x 3 = 21 7 x 4 = 28 7 x 5 = 35 7 x 6 = 42 7 x 7 = 49 7 x 8 = 56 7 x 9 = 63 -------------------------------------------------- 8 x 1 = 8 8 x 2 = 16 8 x 3 = 24 8 x 4 = 32 8 x 5 = 40 8 x 6 = 48 8 x 7 = 56 8 x 8 = 64 8 x 9 = 72 -------------------------------------------------- 9 x 1 = 9 9 x 2 = 18 9 x 3 = 27 9 x 4 = 36 9 x 5 = 45 9 x 6 = 54 9 x 7 = 63 9 x 8 = 72 9 x 9 = 81 -------------------------------------------------- 다른 예제https://wikidocs.net/104141 end=” “ -&gt; 한줄로 표현해주기 위한 것이다. 1234for i in range(10): for j in range(1, 11): print(j, end=&quot; &quot;) print() 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10 1234for i in range(10): for j in range(1, 11): print(j, end=&quot; &quot;) print(&quot;-&gt;&gt;&gt;&gt;&quot;, i) 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 0 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 1 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 2 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 3 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 4 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 5 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 6 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 7 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 8 1 2 3 4 5 6 7 8 9 10 -&gt;&gt;&gt;&gt; 9 공포의 별찍기 문제 단서 1234for i in range(1, 11): for j in range(1, i+1): print('*', end=&quot;&quot;) print() * ** *** **** ***** ****** ******* ******** ********* ********** 실습1 위의 별을 좌우반전으로 찍어보자. 1234for i in range(10): for j in range(1, i+1): print(&quot; &quot; * i + '*', end=&quot;&quot;) print() * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 원하는 답이 아니다.. 1234for i in range(10): for j in range(1, i+1): print(&quot; &quot; * (10-i) + '*', end=&quot;&quot;) print() * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 막 이상하게 나온다.. 1234for i in range(10): for j in range(1, i+1): print(&quot; &quot; * (9-i) + '*', end=&quot;&quot;) print() * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * ********* 강의 바로 for문부터 들어가지 마라 한 줄씩 쳐보고 패턴을 파악해라 123print(&quot; &quot; * 9, &quot;*&quot; * 1)print(&quot; &quot; * 8, &quot;*&quot; * 2)print(&quot; &quot; * 7, &quot;*&quot; * 3) * ** *** 1234for i in range(10): for j in range(1, i+1): print(&quot; &quot; * (9-i) + &quot;*&quot; * j, end=&quot;&quot;) print() * * ** * ** *** * ** *** **** * ** *** **** ***** * ** *** **** ***** ****** * ** *** **** ***** ****** ******* * ** *** **** ***** ****** ******* ******** ********************************************* 이상해졌는데? 1234for i in range(10): for j in range(1, i+1): print(&quot; &quot; * (10-j), &quot;*&quot; * j) print() * * ** * ** *** * ** *** **** * ** *** **** ***** * ** *** **** ***** ****** * ** *** **** ***** ****** ******* * ** *** **** ***** ****** ******* ******** * ** *** **** ***** ****** ******* ******** ********* 어? 다왔는데? 123for j in range(1, 11): print(&quot; &quot; * (10-j), &quot;*&quot; * j) * ** *** **** ***** ****** ******* ******** ********* ********** 와 결국해냈당. 6번 시도후 완성했다.","link":"/2022/03/31/multi_for_loop/"},{"title":"pd.drop() 메서드","text":"Pandas.DataFrame.drop 프로젝트를 진행중에 아래와 같은 코드를 만났다.train.drop([“PassengerId”], axis = 1, inplace = True) 자꾸 에러가 나길래, 공부를 좀 해봤다. 출처 : https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop.html DataFrame.drop(labels=None, axis=0, index=None, columns=Nome, level=None, inplace=False, errors=’raise’) Drop은 행과 열로부터 레이블들을 지정한다. 레이블 이름과 대응되는 축을 지정해줌으로써 행과 열을 지운다. 또는 직접적인 인덱스나 열 이름을들 지정해줌으로써 행과 열을 지운다. 다중 인덱스(multi-index)를 사용할 경우 등급을 지정해줌으로써 다른 등급의 레이블도 지울 수 있다. Parameterslabels single label or list-like 인덱스 또는 열 레이블을 지운다. 튜플은 single label 취급한다. list로 취급하지 않는다. axis 0 or ‘index : 인덱스 자체를 지운다. 1 or ‘columns’ : 열 자체를 지운다. default는 0 index single label or list-like axis를 지정해주는 것 대신에 columns single label or list-like axis를 지정해주는 것 대신에 아래 예제에서 확인하자. level int or level name, optional 다중인덱스(multiindex)의 경우, 레이블들이 있는 단계가 지워진다 inplace bool default는 False False라면, 복사를 반환하고 True라면, 덮어씌우고 아무것도 반환하지 않는다. errors ‘ignore’, ‘raise’ default는 ‘raise’ ‘ignore’를 넣어주면 에러를 막아주고, 존재하는 레이블만 지워준다. 예제 아래 데이터프레임이 있다. 아래 데이터프레임에는 name, price, rating, category 칼럼이 있다. 1234567import pandas as pddf = pd.DataFrame( {'name': ['coffee', 'tea', 'juice', 'milk', 'ade'], 'price': [3000, 4000, 5000, 2000, 5000], 'rating': [4, 3.5, 3.7, 3, 2], 'category': [1,2,3,4,4]})display(df) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name price rating category 0 coffee 3000 4.0 1 1 tea 4000 3.5 2 2 juice 5000 3.7 3 3 milk 2000 3.0 4 4 ade 5000 2.0 4 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-03f7980f-018b-4feb-b381-386855cfd372 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-03f7980f-018b-4feb-b381-386855cfd372'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 여기서 category 칼럼을 지워보자 1df.drop(columns = ['category']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name price rating 0 coffee 3000 4.0 1 tea 4000 3.5 2 juice 5000 3.7 3 milk 2000 3.0 4 ade 5000 2.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-65c3339a-f6d5-470a-96a2-5b43242329b2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-65c3339a-f6d5-470a-96a2-5b43242329b2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 2개 이상의 칼럼을 지울 때는? 1df.drop(columns=['category', 'rating']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name price 0 coffee 3000 1 tea 4000 2 juice 5000 3 milk 2000 4 ade 5000 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-5efa99d7-8bc7-4ac8-a90e-fbd405eaa342 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-5efa99d7-8bc7-4ac8-a90e-fbd405eaa342'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 칼럼을 삭제하는 다른 방법 필요한 칼럼만 불러오기 1df[['name', 'rating']] .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name rating 0 coffee 4.0 1 tea 3.5 2 juice 3.7 3 milk 3.0 4 ade 2.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-2a44dfa2-7d6c-4c48-bfa6-7969303817c5 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-2a44dfa2-7d6c-4c48-bfa6-7969303817c5'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; inplace = True drop() 메서드에 매개변수를 추가해보자. 비교를 위해 먼저, inplace = True를 쓰지 말고 코드를 실행해보자 1df.drop(columns=['category']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name price rating 0 coffee 3000 4.0 1 tea 4000 3.5 2 juice 5000 3.7 3 milk 2000 3.0 4 ade 5000 2.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-5086c77d-5667-4bb0-a196-a74b3665357c button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-5086c77d-5667-4bb0-a196-a74b3665357c'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; category 칼럼이 아주 잘 지워졌다. 여기서 다시 원래 데이터프레임을 불러온다면, 1display(df) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name price rating category 0 coffee 3000 4.0 1 1 tea 4000 3.5 2 2 juice 5000 3.7 3 3 milk 2000 3.0 4 4 ade 5000 2.0 4 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-b24808c0-5065-4c8c-9397-263a4a522c43 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-b24808c0-5065-4c8c-9397-263a4a522c43'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; category 칼럼이 다시 나타나는 것을 볼 수 있다. 별도로 df라는 객체에 저장을 안해주었기 때문이다. inplace 변수를 사용12df.drop(columns=['category'], inplace=True)display(df) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } name price rating 0 coffee 3000 4.0 1 tea 4000 3.5 2 juice 5000 3.7 3 milk 2000 3.0 4 ade 5000 2.0 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-6f6d9f85-c19c-465d-ae27-10140142fe5d button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-6f6d9f85-c19c-465d-ae27-10140142fe5d'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; inplace = True는 기존 데이터프레임에 덮어 씌우겠다는 것이다. 따로 저장하는 수고로움을 덜어주는 매개변수인 것이다. 다른 예제1234import numpy as npdf = pd.DataFrame(np.arange(12).reshape(3, 4), columns=['A', 'B', 'C', 'D'])df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 0 0 1 2 3 1 4 5 6 7 2 8 9 10 11 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8a517d47-71f1-4d40-a5fd-3060a7999df2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8a517d47-71f1-4d40-a5fd-3060a7999df2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 열 지우기 axis = 1 12# axis=1 -&gt; 열 단위로 지워라df.drop(['B', 'C'], axis=1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A D 0 0 3 1 4 7 2 8 11 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-8e52a252-c610-46b6-91da-1dd04e7d231a button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-8e52a252-c610-46b6-91da-1dd04e7d231a'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; axis 매개변수 대신에 columns 매개변수를 넣어줘도 동일하다. 12df.drop(columns=['B', 'C']) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A D 0 0 3 1 4 7 2 8 11 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-a08dbce1-fcde-4c84-b9e8-c185688bcff1 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-a08dbce1-fcde-4c84-b9e8-c185688bcff1'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 행 지우기 인덱스를 통한 방법 1df.drop([0, 1]) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } A B C D 2 8 9 10 11 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-6b39b6e6-43b6-4a88-b4a0-09c28594ead1 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-6b39b6e6-43b6-4a88-b4a0-09c28594ead1'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 다중 인덱스로 열이나 행 지우기12345678910midx = pd.MultiIndex(levels=[['lama', 'cow', 'falcon'], ['speed', 'weight', 'length']], codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2], [0, 1, 2, 0, 1, 2, 0, 1, 2]])df = pd.DataFrame(index=midx, columns=['big', 'small'], data=[[45, 30], [200, 100], [1.5, 1], [30, 20], [250, 150], [1.5, 0.8], [320, 250], [1, 0.8], [0.3, 0.2]])df .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } big small lama speed 45.0 30.0 weight 200.0 100.0 length 1.5 1.0 cow speed 30.0 20.0 weight 250.0 150.0 length 1.5 0.8 falcon speed 320.0 250.0 weight 1.0 0.8 length 0.3 0.2 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-9c8e9bb3-86d7-4bfe-8187-b190cbaa4ac9 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-9c8e9bb3-86d7-4bfe-8187-b190cbaa4ac9'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 위 데이터 프레임에서 ‘falcon’의 ‘weight’를 지우기 1df.drop(index=('falcon', 'weight')) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } big small lama speed 45.0 30.0 weight 200.0 100.0 length 1.5 1.0 cow speed 30.0 20.0 weight 250.0 150.0 length 1.5 0.8 falcon speed 320.0 250.0 length 0.3 0.2 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-fc708903-fd28-49e1-8747-c17b53c42861 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-fc708903-fd28-49e1-8747-c17b53c42861'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; ‘cow’ 인덱스와 ‘small’ 열 지우기 1df.drop(index='cow', columns='small') .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } big lama speed 45.0 weight 200.0 length 1.5 falcon speed 320.0 weight 1.0 length 0.3 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-0268e32a-e810-4e90-9aa7-ee48a261a652 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-0268e32a-e810-4e90-9aa7-ee48a261a652'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt; 모든 인덱스에 ‘length’ 지우기 1df.drop(index='length', level=1) .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } big small lama speed 45.0 30.0 weight 200.0 100.0 cow speed 30.0 20.0 weight 250.0 150.0 falcon speed 320.0 250.0 weight 1.0 0.8 &lt;svg xmlns=”http://www.w3.org/2000/svg&quot; height=”24px”viewBox=”0 0 24 24” width=”24px”&gt; .colab-df-container { display:flex; flex-wrap:wrap; gap: 12px; } .colab-df-convert { background-color: #E8F0FE; border: none; border-radius: 50%; cursor: pointer; display: none; fill: #1967D2; height: 32px; padding: 0 0 0 0; width: 32px; } .colab-df-convert:hover { background-color: #E2EBFA; box-shadow: 0px 1px 2px rgba(60, 64, 67, 0.3), 0px 1px 3px 1px rgba(60, 64, 67, 0.15); fill: #174EA6; } [theme=dark] .colab-df-convert { background-color: #3B4455; fill: #D2E3FC; } [theme=dark] .colab-df-convert:hover { background-color: #434B5C; box-shadow: 0px 1px 3px 1px rgba(0, 0, 0, 0.15); filter: drop-shadow(0px 1px 2px rgba(0, 0, 0, 0.3)); fill: #FFFFFF; } &lt;script&gt; const buttonEl = document.querySelector('#df-66624418-0a6c-42d1-8fb4-aa14716959d2 button.colab-df-convert'); buttonEl.style.display = google.colab.kernel.accessAllowed ? 'block' : 'none'; async function convertToInteractive(key) { const element = document.querySelector('#df-66624418-0a6c-42d1-8fb4-aa14716959d2'); const dataTable = await google.colab.kernel.invokeFunction('convertToInteractive', [key], {}); if (!dataTable) return; const docLinkHtml = 'Like what you see? Visit the ' + '&lt;a target=&quot;_blank&quot; href=https://colab.research.google.com/notebooks/data_table.ipynb&gt;data table notebook&lt;/a&gt;' + ' to learn more about interactive tables.'; element.innerHTML = ''; dataTable['output_type'] = 'display_data'; await google.colab.output.renderOutput(dataTable, element); const docLink = document.createElement('div'); docLink.innerHTML = docLinkHtml; element.appendChild(docLink); } &lt;/script&gt; &lt;/div&gt;","link":"/2022/04/01/pd_drop()/"},{"title":"데이터 전처리 ch2_2","text":"데이터 전처리 데이터 전처리는 머신러닝 모델에 훈련 데이터를 주입하기 전에 가공하는 단계를 말한다. 표준점수는 훈련 세트의 스케일(단위)을 바꾸는 대표적인 방법 중 하나이다. 표준점수를 얻으려면 특성의 평균을 빼고 표준편차로 나눈다. 브로드캐스팅은 크기가 다른 넘파이 배열에서 자동으로 사칙 연산을 모든 행이나 열로 확장하여 수행하는 기능이다. train_test_split, kneighbors() 넘파이로 데이터 준비하기12345678fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5, 34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0, 38.5, 38.5, 39.5, 41.0, 41.0, 9.8, 10.5, 10.6, 11.0, 11.2, 11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0, 450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0, 700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0, 700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0, 925.0, 975.0, 950.0, 6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9] 1import numpy as np 넘파이의 column_stack() 함수는 전달받은 리스트를 일렬로 세운 다음 차례대로 나란히 연결한다. 1np.column_stack(([1, 2, 3], [4, 5, 6])) array([[1, 4], [2, 5], [3, 6]]) 이 방법으로 fish_length와 fish_weight를 합친다. 1234fish_data = np.column_stack((fish_length, fish_weight))# 두 리스트가 잘 연결 되었는지 확인print(fish_data[:5]) [[ 25.4 242. ] [ 26.3 290. ] [ 26.5 340. ] [ 29. 363. ] [ 29. 430. ]] 타깃 데이터12print(np.ones(5))print(np.zeros(5)) [1. 1. 1. 1. 1.] [0. 0. 0. 0. 0.] 이 두 함수를 가지고 1이 35개인 배열과 0이 14개인 배열을 만든다. 그다음 두 배열을 연결한다. np.column_stack() 함수를 사용하지 않고 첫 번째 차원을 따라 배열을 연결하는 np.concatenate() 함수를 사용한다. 12fish_target = np.concatenate((np.ones(35), np.zeros(14)))print(fish_target) [1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] 데이터가 클수록 파이썬 리스트는 비효율적이므로 넘파이 배열을 사용하는 게 좋다. 사이킷 런으로 훈련 세트와 테스트 세트 나누기train_test_split() 함수 훈련 데이터를 훈련 세트와 테스트 세트로 나누는 함수이다. 여러 개의 배열을 전달할 수 있다. 테스트 세트로 나눌 비율은 test_size 매개변수에서 지정할 수 있으며 기본값은 0.25이다. shuffle 매개변수로 훈련 세트와 테스트 세트로 나누기 전에 무작위로 섞을지 여부를 결정할 수 있다. 기본값은 True. stratify 매개변수에 클래스 레이블이 담긴 배열(일반적으로 타깃 데이터)을 전달하면 클래스 비율에 맞게 훈련 세트와 테스트 세트를 나눈다. 1from sklearn.model_selection import train_test_split train_test_split() 함수에는 자체적으로 랜덤 시드를 지정할 수 있는 random_stat 매개변수가 있다. 123# fish_data와 fish_target을 나눈다.train_input, test_input, train_target, test_target = train_test_split( fish_data, fish_target, random_state = 42) 2개의 배열을 전달했으므로 2개씩 나뉘어 총 4개의 배열이 반환된다. 123# 잘 나누었는지 확인print(train_input.shape, test_input.shape)print(train_target.shape, test_target.shape) (36, 2) (13, 2) (36,) (13,) 훈련 데이터와 테스트 데이터를 36개와 13개로 나누었다. 입력 데이터는 2개의 열이 있는 2차원 배열이고 타깃 데이터는 1차원 배열이다. 도미와 빙어가 잘 섞였는지 테스트 데이터를 출력해본다. 1print(test_target) [1. 0. 0. 0. 1. 1. 1. 1. 1. 1. 1. 1. 1.] 13개의 테스트 세트 중에 10개가 도미(1)이고, 3개가 빙어(0)이다. 빙어의 비율이 조금 모자르다. 원래 2.5:1 비율이었는데, 테스트 세트의 비율은 3.3:1으로 샘플링 편향이 나타났다. stratify 매개변수 이것을 활용해 비율을 맞출 수 있다. 해당 매개변수에 타깃 데이터를 전달하면 된다. 12train_input, test_input, train_target, test_target = train_test_split( fish_data, fish_target, stratify = fish_target, random_state = 42) 1print(test_target) [0. 0. 1. 0. 1. 0. 1. 1. 1. 1. 1. 1. 1.] 빙어가 한 마리 늘어나면서 테스트 세트의 비율도 2.25:1이 되었다. 수상한 도미 한 마리 앞서 준비한 데이터로 k-최근접 이웃 모델로 훈련해보자. 1234from sklearn.neighbors import KNeighborsClassifierkn = KNeighborsClassifier()kn.fit(train_input, train_target)kn.score(test_input, test_target) 1.0 이 모델에 김 팀장이 알려준 도미 데이터를 넣고 결과를 확인하면 당연히 도미로 예측할까? 1print(kn.predict([[25, 150]])) [0.] 당황스러운 결과가 도출. 시각화로 확인해보자. 1234567import matplotlib.pyplot as pltfig, ax = plt.subplots()ax.scatter(train_input[:, 0], train_input[:, 1])ax.scatter(25, 150, marker='^')ax.set_xlabel('length')ax.set_ylabel('weight')plt.show() 분명히 도미쪽에 가까운 것 같은데… 이상하다. 이 샘플의 주변 샘플을 알아보자. KNeighborsClassifier 클래스의 kneighbors() 메서드를 활용한다. 기본값은 5로, 5개의 이웃이 반환된다. 1distances, indexes = kn.kneighbors([[25, 150]]) 시각화로 표현해보자. 1234567fig, ax = plt.subplots()plt.scatter(train_input[:,0], train_input[:,1])plt.scatter(25, 150, marker='^')plt.scatter(train_input[indexes, 0], train_input[indexes, 1], marker='D') # marker='D' 는 마름모plt.xlabel('length')plt.ylabel('weight')plt.show() 이웃한 샘플이 빙어가 4개, 도미가 1개구나! 1print(train_input[indexes]) [[[ 25.4 242. ] [ 15. 19.9] [ 14.3 19.7] [ 13. 12.2] [ 12.2 12.2]]] 1print(train_target[indexes]) [[1. 0. 0. 0. 0.]] 왜 가장 가까운 이웃을 빙어라고 생각한 걸까? 실마리를 찾기 위해 distances 배열을 출력해보자. 이 배열에는 이웃 샘플까지의 거리가 담겨 있다. 1print(distances) [[ 92.00086956 130.48375378 130.73859415 138.32150953 138.39320793]] 기준을 맞춰라 x축은 범위가 좁고(1040), y축은 범위가 넓다(01000). 이를 명확히 확인하기 위해 x축의 범위를 동일하게 0~1000으로 맞추어 보자. xlim() 함수를 사용한다. 12345678fig, ax = plt.subplots()plt.scatter(train_input[:,0], train_input[:,1])plt.scatter(25, 150, marker='^')plt.scatter(train_input[indexes, 0], train_input[indexes, 1], marker='D') # marker='D' 는 마름모plt.xlim((0, 1000))plt.xlabel('length')plt.ylabel('weight')plt.show() 산점도가 거의 일직선으로 나타난다. 이런 데이터라면 생선의 길이(x축)는 가장 가까운 이웃을 찾는 데 크게 영향을 미치지 못한다. 오로지 생선의 무게(y축)만 고려 대상이 된다. 스케일(scale) 두 특성의 값이 놓인 범위가 다르다 = 두 특성의 스케일이 다르다 스케일을 같게 만들어 주는 것이 데이터 전처리(data preprocessing)이다. 데이터 전처리 가장 널리 사용하는 전처리 방법은 표준점수(standard score)이다. 123mean = np.mean(train_input, axis=0)std = np.std(train_input, axis=0)print(mean, std) [ 27.29722222 454.09722222] [ 9.98244253 323.29893931] axis=0은 행을 따라(아래방향), axis=1은 열을 따라(오른쪽방향) 통계값을 계산한다. 각 특성마다 평균과 표준편차가 구해졌다. 12# 표준점수train_scaled = (train_input-mean) / std 브로드캐스팅(broadcasting) 넘파이는 train_input의 모든 행에서 mean에 있는 두 평균값을 빼준다. 그다음 std에 있는 두 표준편차를 모든 행에 적용한다. 이러한 넘파이의 기능을 브로드캐스팅이라고 한다. 전처리 데이터로 모델 훈련하기12345plt.scatter(train_scaled[:,0], train_scaled[:,1])plt.scatter(25, 150, marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show() 주황색 세모가 동떨어져 있는 것은 당연하다. 표준화해주지 않았기 때문이다. 표준화를 해주고 다시 시각화해보자. 123456new = ([25, 150] - mean) / stdplt.scatter(train_scaled[:,0], train_scaled[:,1])plt.scatter(new[0], new[1], marker='^')plt.xlabel('length')plt.ylabel('weight')plt.show() x축과 y축의 범위가 -1.5~1.5 사이로 바뀌었다. 이제 이 데이터셋으로 k-최근접 이웃 모델을 다시 훈련해 보자. 1kn.fit(train_scaled, train_target) KNeighborsClassifier() 1test_scaled = (test_input - mean) /std 12# 평가kn.score(test_scaled, test_target) 1.0 앞서 골칫거리를 도미로 예측하는지 확인해보자 1print(kn.predict([new])) [1.] 제대로 예측했다. 그림으로 다시 확인해보자 아까와는 달리 가장 가까운 이웃에 변화가 생겼을 것이다. 1234567distances, indexes = kn.kneighbors([new])plt.scatter(train_scaled[:, 0], train_scaled[:, 1])plt.scatter(new[0], new[1], marker='^')plt.scatter(train_scaled[indexes, 0], train_scaled[indexes, 1], marker='D')plt.xlabel('length')plt.ylabel('weight')plt.show() 주황색 세모가 가장 가까운 샘플은 모두 도미임을 확인했다.","link":"/2022/04/05/ch_2_2/"},{"title":"혼동행렬","text":"혼동행렬(Confusion matrix) 모델의 성능을 평가할 때 사용되는 지표 지도학습에서 알고리즘의 성능을 시각화 할 수 있는 표를 말한다. 분류 모델을 학습하는 것의 목적은 주어진 데이터를 의도에 맞게 잘 분류해내기 위한 것이다. 그렇다면 이러한 모델을 평가하는 기준이 필요할 것이다. 모델을 평가할 때는 모델이 얼마나 정밀한지, 얼마나 실용적인 분류를 했는지, 얼마나 정확한 분류를 했는지를 평가해야 한다. 이러한 내용들을 모두 포함하고 있는 것이 혼동행렬이다. 네 가지 상황 TP(True Positive) : 맞는 것을 올바르게 맞다고 예측한 것 TN(True Negative) : 아닌 것을 틀리다고 예측한 것 FP(False Positive) : 아닌 것을 맞다고 예측한 것 FN(False Negative) : 맞는 것을 틀리다고 예측한 것 정밀도(Precision) 정밀도란 모델이 True라고 분류한 것 중에서 실제 True인 것의 비율이다. Precision = TP / (TP + FP) PPV(Positive Predictive Value) Positive 정답률 재현율(Recall) 실제 True인 것 중에서 모델이 True라고 예측한 것의 비율이다. Recall = TP / (TP + FN) 통계학에서는 sensitivity 다른 분야에서는 hit rate 정확도(Accuracy) True를 True라고 옳게 예측한 경우와 False를 False라고 옳게 예측한 것의 비율이다. Accuracy = (TP + TN) / (TP + FN + FP + TN) 특이도 (Specificity) TNR(True Negative Rate) 실제로는 False일때 , False라고 예측한 것의 비율이다.Specificity = TN / (TN + FP) F1 score Precision과 Recall의 조화평균이다. 2 * (Precision X Recall) / (Precision + Recall) F1 스코어는 데이터 레이블이 불균형 구조일 때, 모델의 성능을 정확하게 평가할 수 있으며, 성능을 하나의 숫자로 표현할 수 있다. Fall-out FPR(False Positive Rate)로 불린다. 실제 False인 data 중에서 모델이 True라고 예측한 비율이다. Fall-out(FPR) = FP / (TN + FP) 출처 : 혼동 행렬, 분류성능평가지표https://data-alpha.tistory.com/22 나무위키https://namu.wiki/w/%ED%98%BC%EB%8F%99%ED%96%89%EB%A0%AC","link":"/2022/04/06/confusion_matrix/"},{"title":"클래스 (Class)","text":"객체를 표현하는 문법 객체를 만들때 유용하다. 클래스 안에 속성(attribute)과 메서드(method)가 있다. 쉬운 비유 과자 틀이 클래스, 과자를 객체라고 생각하자. 클래스 만들기 클래스 이름은 대문자로 시작한다. 코드는 반드시 들여쓰기 해야한다. 123class Person: # 클래스 이름 def greeting(self): # 메서드 print('Hi') # 코드 만든 클래스 사용해보기1ester = Person() ester가 Person의 인스턴스(instance)이다. 클래스는 특정 개념을 표현만 할 뿐 사용하려면 인스턴스를 생성해야 한다. 객체를 생성해야 한다는 소리다. 메서드 호출하기1ester.greeting() Hi 이렇게 인스턴스를 통해 호출하는 메서드를 인스턴스 메서드 라고 한다. 사칙연산 클래스 만들기12class Fourcal: pass 12a = Fourcal()type(a) __main__.Fourcal 1234class Fourcal: def setdata(self, first, second): self.first = first self.second = second 12a = Fourcal()a.setdata(4, 2) setdata 메서드에는 총 3개의 매개변수(self, first, second)를 전달해줘야 할 것 같은데 왜 2개만 전달해줬을까? self에는 객체 a가 자동으로 전달되기 떄문이다. 1234a = Fourcal()a.setdata(4, 2)print(a.first)print(a.second) 4 2 더하기 기능 만들기 1234567class Fourcal: def setdata(self, first, second): self.first = first self.second = second def add(self): result = self.first + self.second return result 123a = Fourcal()a.setdata(4, 2)print(a.add()) 6 빼기,곱하기, 나누기 추가 12345678910111213141516class Fourcal: def setdata(self, first, second): self.first = first self.second = second def add(self): result = self.first + self.second return result def mul(self): result = self.first * self.second return result def sub(self): result = self.first - self.second return result def div(self): result = self.first / self.second return result 123456789a = Fourcal()b = Fourcal()a.setdata(4, 2)b.setdata(3, 8)print(a.add())print(a.mul())print(a.sub())print(a.div()) 6 8 2 2.0 파이썬에서 흔히 보는 클래스 int list dict 12a = int(7)a 7 12b = list(range(10))b [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 12c = dict(x=10, y=20)c {'x': 10, 'y': 20} list 클래스에서 메서드 append 호출하기12b.append(20)b [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 20] type으로 객체(인스턴스)가 어떤 클래스인지 식별하기12345print(type(a))print(type(b))print(type(c))print(type(ester)) &lt;class 'int'&gt; &lt;class 'list'&gt; &lt;class 'dict'&gt; &lt;class '__main__.Person'&gt; 빈 클래스 만들기12class Piano: pass 메서드 안에서 메서드 호출하기123456789class Person: def greeting(self): print('Helu') def hello(self): self.greeting()dexter = Person()dexter.hello() Helu isinstance 함수 현재 인스턴스가 특정 클래스의 인스턴스인지 확인 12345class Pineapple: passcodi = Pineapple()isinstance(codi, Pineapple) True isinstance 함수 활용 팩토리얼 함수를 만들기 위해 n이 int 클래스의 인스턴스인지 확인하는데 활용되었다. 12345678def factorial(n): if not isinstance(n, int) or n &lt; 0: return None if n == 1: return 1 return n * factorial(n -1) factorial(5) 120 출처 파이썬 코딩도장 : 클래스와 메서드 만들기https://dojang.io/mod/page/view.php?id=2372 점프 투 파이썬 : 클래스https://wikidocs.net/28","link":"/2022/04/11/class_1/"},{"title":"Visual Studio에서 python파일 실행하기","text":"컨트롤 + 엔터로는 실행이 안된다. 실행하고자 하는 코드는 faker라는 라이브러리를 이용하여 csv파일을 생성하는 코드이다. Step 1. 터미널 경로 터미널 경로를 잡아줘야 한다. 현재 이 파일은 c드라이브 &gt; airflow-test &gt; ch.3에 있다. 파일이 있는 경로에서 명령어를 실행해야한다. 참고로, cd .. : 상위 폴더로 가기 cd {폴더명} : 해당 폴더로 가기 ls : 현재 경로에서 갈 수 있는 폴더 보기 Step 2. python3 {파일이름} 현재 파일 명은 step01_writecsv.py이다. 따라서, python3 step01_writecsv.py 를 쳐주면 된다. Step 3. 실행시키기 현재 폴더(ch.3)에는 csv파일이 없다. 코드를 실행 시켜보면 csv파일이 생길 것이다. 짜잔! data.csv 파일이 생겼다.","link":"/2022/04/14/Visual_Studio_python/"},{"title":"클래스 2 생성자와 속성","text":"생성자(constructor) 123456789101112131415161718# 기존의 만든 FourCal 클래스class FourCal: def setdata(self, first, second): self.first = first self.second = second def add(self): result = self.first + self.second return result def mul(self): result = self.first * self.second return result def sub(self): result = self.first - self.second return result def div(self): result = self.first / self.second return result 객체에 초깃값을 설정해야 할 필요가 있을 때는 생성자를 구현하는 것이 안전한 방법이다. 생성자란 객체가 생성될 때 자동으로 호출되는 메서드를 의미한다. 생성자를 한 번 추가해보자. 12345678910111213141516171819202122class FourCal: # 생성자 부분 def __init__(self, first, second): self.first = first self.second = second def setdata(self, first, second): self.first = first self.second = second def add(self): result = self.first + self.second return result def mul(self): result = self.first * self.second return result def sub(self): result = self.first - self.second return result def div(self): result = self.first / self.second return result init 매서드는 setdata메서드와 이름만 다르고 모든 게 동일하다. 객체가 생성되는 시점에 자동으로 호출되는 차이만 있을 뿐이다. 123456a = FourCal(4, 2)print(a.first)print(a.second)print(a.add())print(a.div()) 4 2 6 2.0 클래스 속성 사용하기1234567891011121314class Person: bag = [] def put_bag(self, stuff): self.bag.append(stuff)james = Person()james.put_bag('book')maria = Person()maria.put_bag('열쇠')print(james.bag)print(maria.bag) ['book', '열쇠'] ['book', '열쇠'] 제임스 가방에는 책을 마리아 가방에는 열쇠를 넣었는데 두 가방 모두 두 개의 소품이 드가있다. 클래스 속성은 클래스에 속해 있으며 모든 인스턴스에서 공유한다. 클래스 속성에 접근할 때는 클래스 이름으로 접근하는 것이 더 명확하다. 12345class Person: bag = [] def put_bag(self, stuff): Person.bag.append(stuff) # 클래스 이름으로 클래스 속성에 접근 속성, 메서드를 찾는 순서 보통 인스턴스, 클래스 순으로 찾는다. 12james.__dict__Person.__dict__ mappingproxy({'__dict__': &lt;attribute '__dict__' of 'Person' objects&gt;, '__doc__': None, '__module__': '__main__', '__weakref__': &lt;attribute '__weakref__' of 'Person' objects&gt;, 'bag': [], 'put_bag': &lt;function __main__.Person.put_bag&gt;}) 속성 사용 하기 init 메서드 안에서 self.속성에 값을 할당한다. 속성은 init 메서드에서 만든다는 점과 self에 점을 붙인 뒤 값을 할당한 다는 점이 중요하다. 123456789class Person: def __init__(self): self.hello = '안녕하세요.' def greeting(self): print(self.hello)james = Person()james.greeting() 안녕하세요. init 메서드에서 self.hello에 ‘안녕하세요’를 넣었다. init 메서드는 인스턴스를 만들 때 호출되는 메서드이다. init 메서드는 initialize를 줄인 말로 인스턴스를 초기화시킨다. 특히 앞뒤로 밑줄 두개가 붙은 메서드는 스페셜 메서드(special method) 또는 매직 메서드(magic method)라고 부르며, 파이썬이 자동으로 호출해주는 메서드이다. 인스턴스(객체)를 만들 때 값 받기 init 메서드에서 self 다음에 값을 받을 매개변수를 지정한다. 매개변수를 self.속성에 넣어준다. 속성에 접근할 때는 “self.속성”의 형식으로 사용해야한다. 123456789101112class Person: def __init__(self, name, age, address): self.hello = '안녕하세요.' self.name = name self.age = age self.address = address def greeting(self): print('{0} 저는 {1}입니다.'.format(self.hello, self.name)) # 속성에 접근할 때karina = Person('카리나', 23, '경기도 수원시 팔달구 지동')karina.greeting() 안녕하세요. 저는 카리나입니다. 클래스 밖에서 속성에 접근할 때 클래스 안에서는 “self.속성” 형식이었다. 밖에서 속성에 접근할 때는 “인스턴스.속성” 형식으로 접근한다. 인스턴스 속성 : 인스턴스를 통해 접근하는 속성 123print('이름:', karina.name)print('나이:', karina.age)print('주소:', karina.address) 이름: 카리나 나이: 23 주소: 경기도 수원시 팔달구 지동 위치 인수와 키워드 인수 위치 인수의 경우, *args를 사용. 매개변수에서 값을 가져오려면 args[숫자]의 형식으로 사용. 123456789101112class Person: def __init__(self, *args): self.name = args[0] self.age = args[1] self.address = args[2]winter = Person(*['김민정', 22, '부산광역시 중구 남포동'])print('이름:', winter.name)print('나이:', winter.age)print('주소:', winter.address) 이름: 김민정 나이: 22 주소: 부산광역시 중구 남포동 키워드 인수의 경우, **kwargs 사용 매개변수에서 값을 가져오려면 “kwargs[‘속성’]”의 형식으로 사용. 1234567891011class Person: def __init__(self, **kwargs): self.name = kwargs['name'] self.age = kwargs['age'] self.address = kwargs['address']ningning = Person(**{'name': '닝이줘', 'age': 21, 'address': '헤이룽장성 하얼빈시'})print('이름:', ningning.name)print('나이:', ningning.age)print('주소:', ningning.address) 이름: 닝이줘 나이: 21 주소: 헤이룽장성 하얼빈시 인스턴스를 생선한 후에 속성 추가하기 인스턴스를 만든 후에도 속성을 추가할 수 있다. “인스턴스.속성 = 값” 이렇게 추가한 속성은 해당 인스턴스에만 생성된다. 12345678# 빈 클래스 만든 뒤 속성 추가하기class Person: passgiselle = Person()giselle.name = '우치나가 애리'print('이름:', giselle.name) 이름: 우치나가 애리 특정 속성만 허용, 다른 속성은 제한 slots에 허용할 속성 이름을 리스트로 넣어주면 된다. 123456789101112class Person: __slots__ = ['name', 'age']samira = Person()samira.name = '사미라'samira.age = 27# samira.address = '슈리마국 아마크라시'# 허용되지 않은 속성은 추가할 때 에러가 발생한다.print('이름:', samira.name)print('나이:', samira.age) 이름: 사미라 나이: 27 출처 05-1 클래스 - 점프 투 파이썬https://wikidocs.net/28 파이썬 코딩 도장 : 34.2 속성 사용하기https://dojang.io/mod/page/view.php?id=2373","link":"/2022/04/19/class_2/"},{"title":"클래스 3 비공개속성","text":"비공개 속성(Private attribute) 비공개 속성 사용하기 비공개 속성(private attribute) : 클래스 밖에서는 접근할 수 없고 클래스 안에서만 사용할 수 있는 속성 속성 앞에 밑줄 두개로 시작한다. 1234567891011# Person 클래스에 지갑 속성 __wallet 추가class Person: def __init__(self, name, age, address, wallet): self.name = name self.age = age self.address = address self.__wallet = wallet # 변수 앞에 밑줄 두개leesin = Person('리신', 35, '아이오니아 어딘가', 10000)# leesin.__wallet 에러 발생# 클래스 밖에서 비공개 속성을 접근하면 에러 발생 1234567891011121314# pay 메서드 만들기class Person: def __init__(self, name, age, address, wallet): self.name = name self.age = age self.address = address self.__wallet = wallet def pay(self, amount): self.__wallet -= amount # 비공개 속성은 클래스 안에서만 접근 가능 print('이제 {0}원 남았네요.'.format(self.__wallet))leesin = Person('리신', 35, '아이오니아 어딘가', 10000)leesin.pay(3000) 이제 7000원 남았네요. 비공개 메서드 속성뿐만 아니라 메서드도 동일하다. 12345678910class Person: def __greeting(self): print('Hi') def hello(self): self.__greeting() # 클래스 안에서는 비공개 메서드를 호출할 수 있다. lux = Person('럭스', 21, '데마시아 궁전', 2000) # lux.__greeting() # 클래스 바깥에서는 비공개 메서드를 호출할 수 없다. 출처 파이썬 코딩 도장: 34.3 비공개 속성 사용하기https://dojang.io/mod/page/view.php?id=2374","link":"/2022/04/21/class_3/"},{"title":"웹 크롤링","text":"웹 크롤링 입문VS 코드로 진행 파이참으로 가상환경 만들기 https://beelinekim.tistory.com/64 beautifulsoup4 설치 https://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-beautiful-soup 라이브러리 설치 (다 쓸지 안 쓸지 모르지만) pip install beautifulsoup4 pip install numpy pip install matplotlib pip install pandas pip install seaborn pip install requests 크몽 : 나무위키 대한민국 1위 프리랜서/아웃소싱 플랫폼. ‘전문성’이라는 무형의 서비스를 제품화하는 비즈니스 모델로, 디자인, IT, 콘텐츠 제작, 마케팅 등 300개 이상의 카테고리를 보유하고 있다. 즉 투잡(부업)을 구할수 있는 사이트다. 크롤링 아웃소싱 홈페이지 https://namu.wiki/w/크몽 웹 크롤링 웹 상의 정보를 쏙 빼오는 것! 필요한 것은 링크 이미지, PDF 도 주소만 알면 다운 받을 수 있다. 한마디로 인터넷상으로 접근이 가능하면 정보를 가져올 수 있다. 실제 실무에서는…(파이썬 기준) 도구가 필요 하다. BeautifulSoup : 가장 일반적인 수집 도구(CSS 통해서 수집) Scrapy (CSS, XPATH) Selenium (CSS, XPATH + JavaScript) 웹사이트에 있는 정보를 가져오는 것이기 때문에 HTML CSS JavaScript (Ajax) 등을 알아야 한다. 간단한 웹사이트 말들기 Index.html html문서를 만들거야 언어는 영어아 는 컨트롤하는영역 - css, JavaScript는 다 에 있다. 간단하게 html 문서를 작성했다. 본격적으로 웹크롤링 실습 파이썬 파일에서 Beautifulsoup(x) → BeautifulSoup(o) 클래스로 변환 됐다. find 메서드로 웹 크롤링 할 부분을 지정 결과 텍스트만 가져오는 메서드 : get_text() 결과 더 많은 메서드는 BeautifulSoup 공식문서를 보고 공부하면 된다. https://www.crummy.com/software/BeautifulSoup/bs4/doc/#installing-beautiful-soup","link":"/2022/04/22/web_crawling/"}],"tags":[],"categories":[{"name":"Python","slug":"Python","link":"/categories/Python/"}]}